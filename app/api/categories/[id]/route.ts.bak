import { prisma } from '@/lib/db';
import { Prisma } from '@prisma/client';
import { z } from 'zod';
import { NextResponse } from 'next/server';

// Esquema para validar el ID en los par√°metros
const ParamsSchema = z.object({
  id: z.string().cuid({ message: "ID de categor√≠a inv√°lido." }),
});

// Esquema para validar la actualizaci√≥n de categor√≠as
const UpdateCategorySchema = z.object({
  name: z.string().min(1, { message: "El nombre es obligatorio." }).optional(),
  description: z.string().optional().nullable(),
  parentId: z.string().cuid({ message: "ID de categor√≠a padre inv√°lido." }).optional().nullable(),
  equipmentTypeId: z.string().cuid({ message: "ID de tipo de equipamiento inv√°lido." }).optional().nullable(), // ‚úÖ NUEVO
  type: z.enum(['SERVICE', 'PRODUCT', 'MIXED']).optional(), // ‚úÖ NUEVO: Permitir actualizar el tipo
  // No permitir cambiar systemId
}).strict(); // No permitir campos extra
/**
 * Handler para obtener una categor√≠a espec√≠fica por ID.
 */
export async function GET(request: Request, { params }: { params: Promise<{ id: string }> }) {
  const resolvedParams = await params;
  
  // Validar ID
  const paramsValidation = ParamsSchema.safeParse(resolvedParams);
  if (!paramsValidation.success) {
    return NextResponse.json({ error: 'ID de categor√≠a inv√°lido.', details: paramsValidation.error.errors }, { status: 400 });
  }
  const { id: categoryId } = paramsValidation.data;

  try {
    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      // Incluir relaciones si es necesario (ej: padre, hijos directos)
      // include: { parent: true, children: true },
    });

    if (!category) {
      return NextResponse.json({ message: `Categor√≠a ${categoryId} no encontrada.` }, { status: 404 });
    }
    return NextResponse.json(category);

  } catch (error) {
    console.error(`Error fetching category ${categoryId}:`, error);
    return NextResponse.json({ message: 'Error interno del servidor.' }, { status: 500 });
  }
}

/**
 * Handler para actualizar una categor√≠a existente.
 */
export async function PUT(request: Request, { params }: { params: Promise<{ id: string }> }) {
  const resolvedParams = await params;
  
  console.log('üîÑ PUT /api/categories/[id] - INICIO');
  console.log('üìã Params recibidos:', resolvedParams);
  
  // Validar ID
  const paramsValidation = ParamsSchema.safeParse(resolvedParams);
  if (!paramsValidation.success) {
    console.log('‚ùå Error de validaci√≥n de params:', paramsValidation.error);
    return NextResponse.json({ error: 'ID de categor√≠a inv√°lido.', details: paramsValidation.error.errors }, { status: 400 });
  }
  const { id: categoryId } = paramsValidation.data;
  console.log('‚úÖ CategoryId validado:', categoryId);

  try {
    const body = await request.json();
    console.log('üì• Body recibido:', body);

    // Validar body
    const validation = UpdateCategorySchema.safeParse(body);
    if (!validation.success) {
      console.log('‚ùå Error de validaci√≥n del body:', validation.error);
      console.log('üìã Errores detallados:', validation.error.format());
      return NextResponse.json(
        { message: 'Datos inv√°lidos.', details: validation.error.format() },
        { status: 400 }
      );
    }
    const updateData = validation.data;
    console.log('‚úÖ Datos validados exitosamente:', updateData);

    // Verificar que se intenta actualizar algo
    if (Object.keys(updateData).length === 0) {
        console.log('‚ùå No hay datos para actualizar');
        return NextResponse.json({ error: 'No se proporcionaron datos para actualizar.' }, { status: 400 });
    }
    
    // Prevenir ciclos: No permitir que una categor√≠a sea su propio padre
    if (updateData.parentId && updateData.parentId === categoryId) {
      return NextResponse.json({ message: 'Una categor√≠a no puede ser su propia categor√≠a padre.' }, { status: 400 });
    }

    // Validar que el parentId pertenezca al mismo systemId
    if (updateData.parentId) {
      // Primero obtener la categor√≠a actual para conocer su systemId
      const currentCategory = await prisma.category.findUnique({
        where: { id: categoryId },
        select: { systemId: true }
      });

      if (!currentCategory) {
        return NextResponse.json({ message: `Categor√≠a ${categoryId} no encontrada.` }, { status: 404 });
      }

      // Verificar que la categor√≠a padre existe y pertenece al mismo sistema
      const parentCategory = await prisma.category.findUnique({
        where: { id: updateData.parentId },
        select: { systemId: true }
      });

      if (!parentCategory) {
        return NextResponse.json({ message: 'La categor√≠a padre especificada no existe.' }, { status: 400 });
      }

      if (parentCategory.systemId !== currentCategory.systemId) {
        return NextResponse.json({ 
          message: 'La categor√≠a padre debe pertenecer al mismo sistema.' 
        }, { status: 400 });
      }
    }

    const updatedCategory = await prisma.category.update({
      where: { id: categoryId },
      data: updateData,
    });

    return NextResponse.json(updatedCategory);

  } catch (error) {
    console.error(`Error updating category ${categoryId}:`, error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2025') {
        return NextResponse.json({ message: `Categor√≠a ${categoryId} no encontrada.` }, { status: 404 });
      }
       if (error.code === 'P2002') {
        return NextResponse.json({ message: 'Ya existe otra categor√≠a con ese nombre.' }, { status: 409 });
      }
       // Error de Foreign Key (parentId no existe)
      if (error.code === 'P2003' && error.meta?.field_name === 'CategoryHierarchy_parentId_fkey (index)') {
         return NextResponse.json({ message: 'La categor√≠a padre especificada no existe.' }, { status: 400 });
      }
      // Podr√≠a haber error P2016 si se intenta crear un ciclo en la jerarqu√≠a, aunque la validaci√≥n manual ayuda
    }
     if (error instanceof SyntaxError) {
       return NextResponse.json({ message: 'JSON inv√°lido' }, { status: 400 });
    }
    return NextResponse.json({ message: 'Error interno del servidor al actualizar.' }, { status: 500 });
  }
}

/**
 * Handler para eliminar una categor√≠a.
 */
export async function DELETE(request: Request, { params }: { params: Promise<{ id: string }> }) {
  const resolvedParams = await params;
  
  // Validar ID
  const paramsValidation = ParamsSchema.safeParse(resolvedParams);
  if (!paramsValidation.success) {
    return NextResponse.json({ error: 'ID de categor√≠a inv√°lido.', details: paramsValidation.error.errors }, { status: 400 });
  }
  const { id: categoryId } = paramsValidation.data;

  try {
    // Intentar eliminar
    await prisma.category.delete({ where: { id: categoryId } });
    return NextResponse.json({ message: `Categor√≠a ${categoryId} eliminada.` }, { status: 200 });

  } catch (error) {
     console.error(`Error deleting category ${categoryId}:`, error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      // P2025: Registro no encontrado
      if (error.code === 'P2025') {
        return NextResponse.json({ message: `Categor√≠a ${categoryId} no encontrada.` }, { status: 404 });
      }
      // P2003: Violaci√≥n de FK (probablemente por onDelete: Restrict en la relaci√≥n padre-hijo)
      // Esto significa que tiene subcategor√≠as y no se puede borrar.
      if (error.code === 'P2003' && error.message.includes('CategoryHierarchy')) {
         return NextResponse.json(
           { message: 'No se puede eliminar la categor√≠a porque tiene subcategor√≠as asociadas.' },
           { status: 409 } // Conflict
         );
      }
    }
    return NextResponse.json({ message: 'Error interno del servidor al eliminar.' }, { status: 500 });
  }
} 