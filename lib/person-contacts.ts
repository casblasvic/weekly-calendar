/**
 * üîó GESTI√ìN DE CONTACTOS M√öLTIPLES PARA PERSONAS
 * Sistema avanzado para manejar m√∫ltiples emails, tel√©fonos y otros contactos
 * por persona, evitando duplicados y gestionando preferencias inteligentemente.
 * 
 * CASOS DE USO:
 * - Persona con email personal + trabajo + Facebook
 * - Empleado con tel√©fono personal + laboral
 * - Detecci√≥n autom√°tica de duplicados por cualquier contacto
 * - Gesti√≥n de contactos "auto-generados" vs "facilitados conscientemente"
 * - Tracking de uso y preferencias din√°micas
 * 
 * @see docs/PERSON_MULTIPLE_CONTACTS_STRATEGY.md
 */

import { prisma } from '@/lib/db';
import { ContactType, ContactContext } from '@prisma/client';

// ===== TIPOS Y INTERFACES =====

export interface PersonContactData {
  id: string;
  contactType: ContactType;
  contactValue: string;
  contactContext: ContactContext;
  isPreferred: boolean;
  isPrimary: boolean;
  isVerified: boolean;
  isAutoGenerated: boolean;
  lastUsedAt?: Date;
  lastProvidedAt?: Date;
  providedSource?: string;
  usageCount: number;
  notes?: string;
}

export interface EffectiveContactData {
  email?: PersonContactData;
  phone?: PersonContactData;
  whatsapp?: PersonContactData;
  allContacts: PersonContactData[];
}

export interface ContactValidationResult {
  isValid: boolean;
  potentialDuplicates: Array<{
    personId: string;
    personName: string;
    contactValue: string;
    contactType: ContactType;
    matchStrength: 'exact' | 'similar';
  }>;
  warnings: string[];
}

// ===== FUNCIONES PRINCIPALES =====

/**
 * A√±ade un nuevo contacto a una persona con validaci√≥n inteligente
 */
export async function addPersonContact(data: {
  personId: string;
  contactType: ContactType;
  contactValue: string;
  contactContext: ContactContext;
  isAutoGenerated?: boolean;
  providedSource?: string;
  systemId: string;
  notes?: string;
}): Promise<PersonContactData> {
  const {
    personId,
    contactType,
    contactValue,
    contactContext,
    isAutoGenerated = false,
    providedSource,
    systemId,
    notes
  } = data;

  // 1. Normalizar el valor del contacto
  const normalizedValue = normalizeContactValue(contactValue, contactType);

  // 2. Verificar si ya existe este contacto para esta persona
  const existingContact = await prisma.personContact.findFirst({
    where: {
      personId,
      contactType,
      contactValue: normalizedValue,
      systemId
    }
  });

  if (existingContact) {
    // Actualizar informaci√≥n si es necesario
    return await prisma.personContact.update({
      where: { id: existingContact.id },
      data: {
        lastUsedAt: new Date(),
        lastProvidedAt: !isAutoGenerated ? new Date() : existingContact.lastProvidedAt,
        usageCount: { increment: 1 },
        providedSource: providedSource || existingContact.providedSource,
        notes: notes || existingContact.notes
      }
    });
  }

  // 3. Determinar si debe ser preferido autom√°ticamente
  const shouldBePreferred = await shouldSetAsPreferred(personId, contactType, isAutoGenerated, systemId);

  // 4. Crear el nuevo contacto
  const newContact = await prisma.personContact.create({
    data: {
      personId,
      contactType,
      contactValue: normalizedValue,
      contactContext,
      isPreferred: shouldBePreferred,
      isPrimary: shouldBePreferred, // El preferido tambi√©n es primario por defecto
      isAutoGenerated,
      lastUsedAt: new Date(),
      lastProvidedAt: !isAutoGenerated ? new Date() : undefined,
      providedSource,
      usageCount: 1,
      notes,
      systemId
    }
  });

  // 5. Si es preferido, desmarcar otros del mismo tipo
  if (shouldBePreferred) {
    await prisma.personContact.updateMany({
      where: {
        personId,
        contactType,
        systemId,
        id: { not: newContact.id }
      },
      data: {
        isPreferred: false
      }
    });
  }

  return newContact;
}

/**
 * Obtiene los contactos efectivos de una persona (los mejores por tipo)
 */
export async function getEffectiveContactData(personId: string, systemId: string): Promise<EffectiveContactData> {
  const allContacts = await prisma.personContact.findMany({
    where: {
      personId,
      systemId
    },
    orderBy: [
      { isPreferred: 'desc' },
      { isPrimary: 'desc' },
      { usageCount: 'desc' },
      { lastUsedAt: 'desc' },
      { createdAt: 'desc' }
    ]
  });

  // Agrupar por tipo y seleccionar el mejor de cada uno
  const contactsByType = new Map<ContactType, PersonContactData>();
  
  allContacts.forEach(contact => {
    if (!contactsByType.has(contact.contactType)) {
      contactsByType.set(contact.contactType, contact);
    }
  });

  return {
    email: contactsByType.get(ContactType.EMAIL),
    phone: contactsByType.get(ContactType.PHONE),
    whatsapp: contactsByType.get(ContactType.WHATSAPP),
    allContacts
  };
}

/**
 * Detecta duplicados potenciales bas√°ndose en un contacto
 */
export async function detectPotentialDuplicates(
  contactValue: string,
  contactType: ContactType,
  systemId: string,
  excludePersonId?: string
): Promise<ContactValidationResult> {
  const normalizedValue = normalizeContactValue(contactValue, contactType);
  
  const existingContacts = await prisma.personContact.findMany({
    where: {
      contactValue: normalizedValue,
      contactType,
      systemId,
      personId: excludePersonId ? { not: excludePersonId } : undefined
    },
    include: {
      person: {
        select: {
          id: true,
          firstName: true,
          lastName: true
        }
      }
    }
  });

  const potentialDuplicates = existingContacts.map(contact => ({
    personId: contact.person.id,
    personName: `${contact.person.firstName} ${contact.person.lastName || ''}`.trim(),
    contactValue: contact.contactValue,
    contactType: contact.contactType,
    matchStrength: 'exact' as const
  }));

  // TODO: Implementar l√≥gica de similitud para detectar contactos "similares"
  // Por ejemplo, n√∫meros de tel√©fono con diferentes formatos

  return {
    isValid: potentialDuplicates.length === 0,
    potentialDuplicates,
    warnings: potentialDuplicates.length > 0 
      ? [`Contacto ${contactValue} ya existe para otra(s) persona(s)`]
      : []
  };
}

/**
 * Marca un contacto como preferido
 */
export async function promoteToPreferred(contactId: string): Promise<PersonContactData> {
  const contact = await prisma.personContact.findUnique({
    where: { id: contactId }
  });

  if (!contact) {
    throw new Error('Contacto no encontrado');
  }

  // Desmarcar otros contactos del mismo tipo como preferidos
  await prisma.personContact.updateMany({
    where: {
      personId: contact.personId,
      contactType: contact.contactType,
      systemId: contact.systemId,
      id: { not: contactId }
    },
    data: {
      isPreferred: false
    }
  });

  // Marcar este como preferido y actualizar uso
  return await prisma.personContact.update({
    where: { id: contactId },
    data: {
      isPreferred: true,
      isPrimary: true,
      lastUsedAt: new Date(),
      usageCount: { increment: 1 }
    }
  });
}

/**
 * Busca personas por cualquier contacto conocido
 */
export async function findPersonsByContact(
  contactValue: string,
  contactType?: ContactType,
  systemId?: string
): Promise<Array<{ person: any; matchedContacts: PersonContactData[] }>> {
  const normalizedValue = normalizeContactValue(contactValue, contactType);
  
  const whereClause: any = {
    contactValue: normalizedValue
  };
  
  if (contactType) {
    whereClause.contactType = contactType;
  }
  
  if (systemId) {
    whereClause.systemId = systemId;
  }

  const contacts = await prisma.personContact.findMany({
    where: whereClause,
    include: {
      person: {
        include: {
          functionalRoles: true
        }
      }
    }
  });

  // Agrupar por persona
  const personMap = new Map();
  
  contacts.forEach(contact => {
    const personId = contact.person.id;
    if (!personMap.has(personId)) {
      personMap.set(personId, {
        person: contact.person,
        matchedContacts: []
      });
    }
    personMap.get(personId).matchedContacts.push(contact);
  });

  return Array.from(personMap.values());
}

/**
 * Migra contactos √∫nicos de Person a PersonContact
 */
export async function migratePersonContactsFromLegacy(systemId: string): Promise<void> {
  const personsWithContacts = await prisma.person.findMany({
    where: {
      systemId,
      OR: [
        { email: { not: null } },
        { phone: { not: null } }
      ]
    }
  });

  for (const person of personsWithContacts) {
    // Migrar email si existe
    if (person.email) {
      await addPersonContact({
        personId: person.id,
        contactType: ContactType.EMAIL,
        contactValue: person.email,
        contactContext: ContactContext.PERSONAL,
        providedSource: 'legacy_migration',
        systemId
      });
    }

    // Migrar tel√©fono si existe
    if (person.phone) {
      await addPersonContact({
        personId: person.id,
        contactType: ContactType.PHONE,
        contactValue: person.phone,
        contactContext: ContactContext.PERSONAL,
        providedSource: 'legacy_migration',
        systemId
      });
    }
  }
}

// ===== FUNCIONES AUXILIARES =====

/**
 * Normaliza el valor de un contacto seg√∫n su tipo
 */
function normalizeContactValue(value: string, type: ContactType): string {
  switch (type) {
    case ContactType.EMAIL:
      return value.toLowerCase().trim();
    case ContactType.PHONE:
    case ContactType.WHATSAPP:
      // Eliminar espacios, guiones y par√©ntesis
      return value.replace(/[\s\-\(\)]/g, '');
    default:
      return value.trim();
  }
}

/**
 * Determina si un nuevo contacto debe marcarse como preferido
 */
async function shouldSetAsPreferred(
  personId: string,
  contactType: ContactType,
  isAutoGenerated: boolean,
  systemId: string
): Promise<boolean> {
  // Los contactos auto-generados nunca son preferidos por defecto
  if (isAutoGenerated) {
    return false;
  }

  // Verificar si ya existe un contacto preferido de este tipo
  const existingPreferred = await prisma.personContact.findFirst({
    where: {
      personId,
      contactType,
      systemId,
      isPreferred: true
    }
  });

  // Si no hay preferido, este ser√° el preferido
  return !existingPreferred;
}

/**
 * Obtiene estad√≠sticas de contactos de una persona
 */
export async function getPersonContactStats(personId: string, systemId: string) {
  const contacts = await prisma.personContact.findMany({
    where: { personId, systemId }
  });

  const stats = {
    total: contacts.length,
    byType: {} as Record<string, number>,
    byContext: {} as Record<string, number>,
    verified: contacts.filter(c => c.isVerified).length,
    autoGenerated: contacts.filter(c => c.isAutoGenerated).length,
    lastUsed: contacts.reduce((latest, contact) => {
      return !latest || (contact.lastUsedAt && contact.lastUsedAt > latest) 
        ? contact.lastUsedAt 
        : latest;
    }, null as Date | null)
  };

  contacts.forEach(contact => {
    stats.byType[contact.contactType] = (stats.byType[contact.contactType] || 0) + 1;
    stats.byContext[contact.contactContext] = (stats.byContext[contact.contactContext] || 0) + 1;
  });

  return stats;
} 