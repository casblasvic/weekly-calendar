# üéØ SISTEMA DE SCORING DE ANOMAL√çAS PARA ENCHUFES INTELIGENTES SHELLY

## üìã **RESUMEN EJECUTIVO**

Sistema optimizado para detecci√≥n de patrones an√≥malos y posibles irregularidades en servicios que utilizan enchufes inteligentes Shelly, reemplazando los perfiles energ√©ticos granulares de clientes y empleados con un enfoque de scoring agregado altamente eficiente.

### üîå **IMPORTANTE: VERIFICACI√ìN DE M√ìDULO SHELLY**

Este sistema **SOLO FUNCIONA** cuando el m√≥dulo de enchufes inteligentes Shelly est√° **ACTIVO** en el marketplace del sistema:

```typescript
import { isShellyModuleActive } from '@/lib/services/shelly-module-service'

// ‚úÖ VERIFICACI√ìN OBLIGATORIA antes de cualquier operaci√≥n
const isActive = await isShellyModuleActive(systemId)
if (!isActive) {
  console.log('üîí M√≥dulo Shelly INACTIVO - Scoring omitido')
  return null
}
```

### üéØ **Objetivos del Sistema**
- **Detecci√≥n de anomal√≠as**: Identificar patrones irregulares en servicios con enchufes inteligentes
- **Optimizaci√≥n de recursos**: Reducir 99.6% el uso de memoria vs sistema anterior
- **Alertas inteligentes**: Notificaciones autom√°ticas por umbral de riesgo
- **An√°lisis de comportamiento**: Patrones de clientes y empleados
- **Prevenci√≥n de irregularidades**: Detecci√≥n temprana de comportamientos sospechosos
- **Integraci√≥n con Shelly**: Funciona solo cuando el m√≥dulo est√° disponible

### üõ°Ô∏è **Control de Acceso por M√≥dulo**

El sistema respeta completamente el estado del m√≥dulo Shelly:

| Estado del M√≥dulo | Comportamiento del Sistema |
|------------------|---------------------------|
| ‚úÖ **Activo** | Todas las funciones operativas |
| ‚ùå **Inactivo** | Funciones retornan `null` gracefully |
| üîÑ **Cargando** | Espera resoluci√≥n del estado |

### üìä **Nomenclatura de Tablas**

Todas las tablas siguen la nomenclatura `smart_plug_*` para mantener consistencia:

- `smart_plug_client_anomaly_scores` - Scoring de clientes
- `smart_plug_employee_anomaly_scores` - Scoring de empleados
- `smart_plug_service_energy_profiles` - Perfiles de servicios (existente)
- `smart_plug_device_usage_insights` - Insights de dispositivos (existente)

---

## üèóÔ∏è **ARQUITECTURA DEL SISTEMA**

### **Comparaci√≥n: Antes vs Despu√©s**

| Aspecto | ‚ùå Sistema Anterior | ‚úÖ Sistema Nuevo |
|---------|-------------------|------------------|
| **Registros** | 48,000 perfiles | 200 scores |
| **Memoria** | ~9.6 MB | ~20 KB |
| **Consultas** | Complejas (JOINs) | Directas por ID |
| **Actualizaci√≥n** | Cada servicio | Solo anomal√≠as |
| **Escalabilidad** | O(n¬≥) | O(n) |
| **Utilidad** | 20% √∫tiles | 100% √∫tiles |

### **Flujo de Datos Optimizado**

```mermaid
graph TD
    A[Servicio Completado] --> B[DeviceUsageInsight]
    B --> C{¬øEs Anomal√≠a?}
    C -->|No| D[Fin - No actualizar]
    C -->|S√≠| E[Actualizar Client Score]
    C -->|S√≠| F[Actualizar Employee Score]
    E --> G[Detectar Patrones Cruzados]
    F --> G
    G --> H[Generar Alertas]
    H --> I[Dashboard Actualizado]
```

---

## üóÑÔ∏è **ESTRUCTURA DE DATOS**

### **1. Tabla: client_anomaly_scores**

```sql
CREATE TABLE client_anomaly_scores (
  id TEXT PRIMARY KEY,
  systemId TEXT NOT NULL,
  clinicId TEXT NOT NULL,
  clientId TEXT NOT NULL,
  
  -- üìä M√©tricas Agregadas
  totalServices INTEGER DEFAULT 0,
  totalAnomalies INTEGER DEFAULT 0,
  anomalyRate DECIMAL(5,2) DEFAULT 0, -- Porcentaje
  
  -- üìà An√°lisis de Desviaciones
  avgDeviationPercent DECIMAL(10,2) DEFAULT 0,
  maxDeviationPercent DECIMAL(10,2) DEFAULT 0,
  
  -- üîç Patrones Detectados
  suspiciousPatterns JSONB DEFAULT '{}', 
  -- Ejemplo: {"overDuration": 5, "underConsumption": 3, "specificEmployee": "emp123"}
  
  favoredByEmployees JSONB DEFAULT '{}',
  -- Ejemplo: {"emp123": 8, "emp456": 3} - anomal√≠as por empleado
  
  -- ‚ö†Ô∏è Score de Riesgo
  riskScore INTEGER DEFAULT 0, -- 0-100
  riskLevel TEXT DEFAULT 'low', -- low, medium, high, critical
  
  -- üïê Metadatos
  lastAnomalyDate TIMESTAMP,
  lastCalculated TIMESTAMP DEFAULT NOW(),
  updatedAt TIMESTAMP DEFAULT NOW(),
  
  -- üîó √çndices
  UNIQUE(systemId, clinicId, clientId)
);

CREATE INDEX idx_client_anomaly_risk ON client_anomaly_scores(riskLevel, riskScore DESC);
CREATE INDEX idx_client_anomaly_system ON client_anomaly_scores(systemId, clinicId);
```

### **2. Tabla: employee_anomaly_scores**

```sql
CREATE TABLE employee_anomaly_scores (
  id TEXT PRIMARY KEY,
  systemId TEXT NOT NULL,
  clinicId TEXT NOT NULL,
  employeeId TEXT NOT NULL,
  
  -- üìä M√©tricas Agregadas
  totalServices INTEGER DEFAULT 0,
  totalAnomalies INTEGER DEFAULT 0,
  anomalyRate DECIMAL(5,2) DEFAULT 0,
  
  -- üìà An√°lisis de Eficiencia
  avgEfficiency DECIMAL(5,2) DEFAULT 100,
  consistencyScore DECIMAL(5,2) DEFAULT 100,
  
  -- üîç Patrones Sospechosos
  favoredClients JSONB DEFAULT '{}',
  -- Ejemplo: {"client123": 8, "client456": 3} - anomal√≠as por cliente
  
  fraudIndicators JSONB DEFAULT '{}',
  -- Ejemplo: {"alwaysExtended": true, "rushHourCutting": true, "energyWaste": false}
  
  timePatterns JSONB DEFAULT '{}',
  -- Ejemplo: {"morning": 2, "afternoon": 8, "evening": 1} - anomal√≠as por per√≠odo
  
  -- ‚ö†Ô∏è Score de Riesgo
  riskScore INTEGER DEFAULT 0,
  riskLevel TEXT DEFAULT 'low',
  
  -- üïê Metadatos
  lastCalculated TIMESTAMP DEFAULT NOW(),
  updatedAt TIMESTAMP DEFAULT NOW(),
  
  -- üîó √çndices
  UNIQUE(systemId, clinicId, employeeId)
);

CREATE INDEX idx_employee_anomaly_risk ON employee_anomaly_scores(riskLevel, riskScore DESC);
CREATE INDEX idx_employee_anomaly_system ON employee_anomaly_scores(systemId, clinicId);
```

---

## üéØ **PATRONES DE ANOMAL√çAS DETECTADOS**

### **Patrones de Clientes**

```typescript
const CLIENT_ANOMALY_PATTERNS = {
  ALWAYS_OVER_TIME: {
    code: 'overDuration',
    description: 'Cliente siempre recibe m√°s tiempo del estimado',
    threshold: '> 20% en 80% de servicios',
    riskImpact: +15
  },
  
  SPECIFIC_EMPLOYEE_ONLY: {
    code: 'specificEmployee',
    description: 'Anomal√≠as solo con empleado espec√≠fico',
    threshold: '> 70% anomal√≠as con mismo empleado',
    riskImpact: +25
  },
  
  TIME_PATTERN_SUSPICIOUS: {
    code: 'timePattern',
    description: 'Anomal√≠as solo en ciertos horarios',
    threshold: '> 80% anomal√≠as en mismo per√≠odo',
    riskImpact: +10
  },
  
  ENERGY_OVERCONSUMPTION: {
    code: 'energyWaste',
    description: 'Consume sistem√°ticamente m√°s energ√≠a',
    threshold: '> 30% sobre consumo en 60% servicios',
    riskImpact: +20
  }
}
```

### **Patrones de Empleados**

```typescript
const EMPLOYEE_ANOMALY_PATTERNS = {
  CONSISTENT_SHORT_SERVICES: {
    code: 'alwaysShort',
    description: 'Siempre termina antes del tiempo estimado',
    threshold: '< -15% duraci√≥n en 70% servicios',
    riskImpact: +20
  },
  
  CLIENT_FAVORITISM: {
    code: 'clientFavoritism',
    description: 'Favorece a clientes espec√≠ficos',
    threshold: '> 60% anomal√≠as con < 20% clientes',
    riskImpact: +30
  },
  
  RUSH_HOUR_CUTTING: {
    code: 'rushHourCutting',
    description: 'Acorta servicios en horas pico',
    threshold: 'Anomal√≠as negativas > 50% en 12-18h',
    riskImpact: +15
  },
  
  INCONSISTENT_PERFORMANCE: {
    code: 'inconsistent',
    description: 'Rendimiento muy variable',
    threshold: 'Desviaci√≥n est√°ndar > 40%',
    riskImpact: +10
  }
}
```

---

## üîÑ **ALGORITMOS DE ACTUALIZACI√ìN**

### **1. Actualizaci√≥n de Score de Cliente**

```typescript
/**
 * üë§ ACTUALIZAR SCORE DE ANOMAL√çA DE CLIENTE
 * 
 * Se ejecuta cada vez que se detecta una anomal√≠a relacionada con un cliente.
 * Utiliza algoritmos incrementales para mantener estad√≠sticas actualizadas.
 * 
 * Variables cr√≠ticas:
 * - clientId: ID del cliente involucrado
 * - deviationPct: Porcentaje de desviaci√≥n de la anomal√≠a
 * - insightType: Tipo de anomal√≠a detectada
 * - employeeId: Empleado que realiz√≥ el servicio
 */
async function updateClientAnomalyScore(params: {
  systemId: string
  clinicId: string
  clientId: string
  deviationPct: number
  insightType: string
  employeeId?: string
}) {
  const { systemId, clinicId, clientId, deviationPct, insightType, employeeId } = params
  
  // üîç Buscar o crear score del cliente
  let score = await prisma.clientAnomalyScore.findFirst({
    where: { systemId, clinicId, clientId }
  })
  
  if (!score) {
    score = await prisma.clientAnomalyScore.create({
      data: {
        id: crypto.randomUUID(),
        systemId,
        clinicId,
        clientId,
        totalServices: 1,
        totalAnomalies: 1,
        anomalyRate: 100,
        avgDeviationPercent: deviationPct,
        maxDeviationPercent: deviationPct,
        suspiciousPatterns: { [insightType]: 1 },
        favoredByEmployees: employeeId ? { [employeeId]: 1 } : {},
        riskScore: calculateClientRiskScore({ anomalyRate: 100, patterns: [insightType] }),
        lastAnomalyDate: new Date()
      }
    })
    
    console.log(`üÜï [CLIENT_SCORE] Nuevo score creado para cliente ${clientId}`)
    return
  }
  
  // üîÑ Actualizar m√©tricas existentes
  const newTotalAnomalies = score.totalAnomalies + 1
  const newAnomalyRate = (newTotalAnomalies / score.totalServices) * 100
  
  // üìä Actualizar desviaci√≥n promedio (algoritmo incremental)
  const newAvgDeviation = (score.avgDeviationPercent * score.totalAnomalies + deviationPct) / newTotalAnomalies
  const newMaxDeviation = Math.max(score.maxDeviationPercent, Math.abs(deviationPct))
  
  // üîç Actualizar patrones sospechosos
  const patterns = score.suspiciousPatterns as any || {}
  patterns[insightType] = (patterns[insightType] || 0) + 1
  
  // üë®‚Äç‚öïÔ∏è Actualizar empleados favorecidos
  const favoredEmployees = score.favoredByEmployees as any || {}
  if (employeeId) {
    favoredEmployees[employeeId] = (favoredEmployees[employeeId] || 0) + 1
  }
  
  // ‚ö†Ô∏è Calcular nuevo score de riesgo
  const newRiskScore = calculateClientRiskScore({
    anomalyRate: newAnomalyRate,
    patterns: Object.keys(patterns),
    favoredEmployees: Object.keys(favoredEmployees).length,
    maxDeviation: newMaxDeviation
  })
  
  await prisma.clientAnomalyScore.update({
    where: { id: score.id },
    data: {
      totalAnomalies: newTotalAnomalies,
      anomalyRate: newAnomalyRate,
      avgDeviationPercent: newAvgDeviation,
      maxDeviationPercent: newMaxDeviation,
      suspiciousPatterns: patterns,
      favoredByEmployees: favoredEmployees,
      riskScore: newRiskScore,
      riskLevel: getRiskLevel(newRiskScore),
      lastAnomalyDate: new Date(),
      updatedAt: new Date()
    }
  })
  
  console.log(`üîÑ [CLIENT_SCORE] Score actualizado para cliente ${clientId}: ${newRiskScore}/100`)
}
```

### **2. Actualizaci√≥n de Score de Empleado**

```typescript
/**
 * üë®‚Äç‚öïÔ∏è ACTUALIZAR SCORE DE ANOMAL√çA DE EMPLEADO
 * 
 * Se ejecuta cada vez que un empleado est√° involucrado en una anomal√≠a.
 * Analiza patrones de comportamiento y eficiencia del empleado.
 * 
 * Variables cr√≠ticas:
 * - employeeId: ID del empleado involucrado
 * - deviationPct: Porcentaje de desviaci√≥n
 * - insightType: Tipo de anomal√≠a
 * - clientId: Cliente involucrado en la anomal√≠a
 * - timeOfDay: Hora del d√≠a cuando ocurri√≥
 */
async function updateEmployeeAnomalyScore(params: {
  systemId: string
  clinicId: string
  employeeId: string
  deviationPct: number
  insightType: string
  clientId?: string
  timeOfDay?: number
}) {
  const { systemId, clinicId, employeeId, deviationPct, insightType, clientId, timeOfDay } = params
  
  // üîç Buscar o crear score del empleado
  let score = await prisma.employeeAnomalyScore.findFirst({
    where: { systemId, clinicId, employeeId }
  })
  
  if (!score) {
    score = await prisma.employeeAnomalyScore.create({
      data: {
        id: crypto.randomUUID(),
        systemId,
        clinicId,
        employeeId,
        totalServices: 1,
        totalAnomalies: 1,
        anomalyRate: 100,
        avgEfficiency: deviationPct > 0 ? 80 : 120, // Ajuste inicial
        consistencyScore: 50, // Baja consistencia inicial
        favoredClients: clientId ? { [clientId]: 1 } : {},
        fraudIndicators: detectFraudIndicators(insightType, deviationPct),
        timePatterns: timeOfDay ? { [getTimePeriod(timeOfDay)]: 1 } : {},
        riskScore: calculateEmployeeRiskScore({ anomalyRate: 100, patterns: [insightType] }),
        lastCalculated: new Date()
      }
    })
    
    console.log(`üÜï [EMPLOYEE_SCORE] Nuevo score creado para empleado ${employeeId}`)
    return
  }
  
  // üîÑ Actualizar m√©tricas existentes
  const newTotalAnomalies = score.totalAnomalies + 1
  const newAnomalyRate = (newTotalAnomalies / score.totalServices) * 100
  
  // üìä Actualizar eficiencia promedio
  const efficiencyImpact = deviationPct > 0 ? -5 : +3 // Penalizar sobre-tiempo, premiar eficiencia
  const newAvgEfficiency = Math.max(0, Math.min(100, score.avgEfficiency + efficiencyImpact))
  
  // üéØ Actualizar consistencia (menos anomal√≠as = m√°s consistencia)
  const newConsistencyScore = Math.max(0, 100 - (newAnomalyRate * 2))
  
  // üë§ Actualizar clientes favorecidos
  const favoredClients = score.favoredClients as any || {}
  if (clientId) {
    favoredClients[clientId] = (favoredClients[clientId] || 0) + 1
  }
  
  // üö® Actualizar indicadores de irregularidades
  const fraudIndicators = updateFraudIndicators(
    score.fraudIndicators as any || {},
    insightType,
    deviationPct,
    newAnomalyRate
  )
  
  // üïê Actualizar patrones temporales
  const timePatterns = score.timePatterns as any || {}
  if (timeOfDay !== undefined) {
    const period = getTimePeriod(timeOfDay)
    timePatterns[period] = (timePatterns[period] || 0) + 1
  }
  
  // ‚ö†Ô∏è Calcular nuevo score de riesgo
  const newRiskScore = calculateEmployeeRiskScore({
    anomalyRate: newAnomalyRate,
    efficiency: newAvgEfficiency,
    consistency: newConsistencyScore,
    favoredClients: Object.keys(favoredClients).length,
    fraudIndicators: Object.keys(fraudIndicators).length
  })
  
  await prisma.employeeAnomalyScore.update({
    where: { id: score.id },
    data: {
      totalAnomalies: newTotalAnomalies,
      anomalyRate: newAnomalyRate,
      avgEfficiency: newAvgEfficiency,
      consistencyScore: newConsistencyScore,
      favoredClients: favoredClients,
      fraudIndicators: fraudIndicators,
      timePatterns: timePatterns,
      riskScore: newRiskScore,
      riskLevel: getRiskLevel(newRiskScore),
      lastCalculated: new Date(),
      updatedAt: new Date()
    }
  })
  
  console.log(`üîÑ [EMPLOYEE_SCORE] Score actualizado para empleado ${employeeId}: ${newRiskScore}/100`)
}
```

---

## üìä **ALGORITMOS DE C√ÅLCULO DE RIESGO**

### **Score de Riesgo de Cliente**

```typescript
function calculateClientRiskScore(params: {
  anomalyRate: number
  patterns: string[]
  favoredEmployees?: number
  maxDeviation?: number
}): number {
  const { anomalyRate, patterns, favoredEmployees = 0, maxDeviation = 0 } = params
  
  let score = 0
  
  // üìä Base: Tasa de anomal√≠as (0-40 puntos)
  score += Math.min(40, anomalyRate * 0.4)
  
  // üîç Patrones sospechosos (0-30 puntos)
  const patternPoints = {
    'overDuration': 10,
    'underDuration': 8,
    'overConsumption': 12,
    'underConsumption': 6,
    'specificEmployee': 15
  }
  
  patterns.forEach(pattern => {
    score += patternPoints[pattern] || 5
  })
  
  // üë®‚Äç‚öïÔ∏è Concentraci√≥n en pocos empleados (0-20 puntos)
  if (favoredEmployees === 1) score += 20
  else if (favoredEmployees === 2) score += 10
  else if (favoredEmployees === 3) score += 5
  
  // üìà Desviaci√≥n m√°xima (0-10 puntos)
  score += Math.min(10, maxDeviation / 10)
  
  return Math.min(100, Math.round(score))
}
```

### **Score de Riesgo de Empleado**

```typescript
function calculateEmployeeRiskScore(params: {
  anomalyRate: number
  efficiency: number
  consistency: number
  favoredClients: number
  fraudIndicators: number
}): number {
  const { anomalyRate, efficiency, consistency, favoredClients, fraudIndicators } = params
  
  let score = 0
  
  // üìä Base: Tasa de anomal√≠as (0-30 puntos)
  score += Math.min(30, anomalyRate * 0.3)
  
  // ‚ö° Penalizar baja eficiencia (0-25 puntos)
  if (efficiency < 70) score += (70 - efficiency) * 0.5
  
  // üéØ Penalizar baja consistencia (0-20 puntos)
  if (consistency < 80) score += (80 - consistency) * 0.25
  
  // üë§ Concentraci√≥n en pocos clientes (0-15 puntos)
  if (favoredClients <= 3 && anomalyRate > 20) score += 15
  else if (favoredClients <= 5 && anomalyRate > 30) score += 10
  
  // üö® Indicadores de irregularidades (0-10 puntos)
  score += Math.min(10, fraudIndicators * 3)
  
  return Math.min(100, Math.round(score))
}
```

---

## üö® **SISTEMA DE ALERTAS**

### **Niveles de Riesgo**

```typescript
function getRiskLevel(score: number): string {
  if (score >= 80) return 'critical'
  if (score >= 60) return 'high'
  if (score >= 40) return 'medium'
  return 'low'
}

const RISK_LEVEL_CONFIG = {
  low: {
    color: 'green',
    icon: '‚úÖ',
    action: 'monitor',
    description: 'Comportamiento normal'
  },
  medium: {
    color: 'yellow', 
    icon: '‚ö†Ô∏è',
    action: 'review',
    description: 'Revisar patrones ocasionalmente'
  },
  high: {
    color: 'orange',
    icon: 'üî∂',
    action: 'investigate',
    description: 'Investigar comportamiento'
  },
  critical: {
    color: 'red',
    icon: 'üö®',
    action: 'immediate_action',
    description: 'Acci√≥n inmediata requerida'
  }
}
```

### **Alertas Autom√°ticas**

```typescript
interface AnomalyAlert {
  id: string
  type: 'client' | 'employee' | 'collusion'
  severity: 'medium' | 'high' | 'critical'
  entityId: string
  entityName: string
  riskScore: number
  patterns: string[]
  message: string
  recommendedAction: string
  createdAt: Date
}

// Ejemplos de alertas generadas autom√°ticamente
const ALERT_TEMPLATES = {
  CLIENT_HIGH_RISK: {
    message: "Cliente {clientName} muestra patrones an√≥malos consistentes",
    recommendedAction: "Revisar historial de servicios y empleados asignados"
  },
  
  EMPLOYEE_FAVORITISM: {
    message: "Empleado {employeeName} muestra favoritism hacia ciertos clientes",
    recommendedAction: "Supervisar servicios con clientes espec√≠ficos"
  },
  
  COLLUSION_DETECTED: {
    message: "Patr√≥n sospechoso entre {employeeName} y {clientName}",
    recommendedAction: "Investigaci√≥n inmediata recomendada"
  }
}
```

---

## üé® **DASHBOARD DE ANOMAL√çAS**

### **Vista Principal**

```typescript
interface AnomalyDashboard {
  // üìä KPIs Generales
  summary: {
    totalClients: number
    clientsAtRisk: number
    totalEmployees: number
    employeesAtRisk: number
    activeAlerts: number
  }
  
  // üö® Alertas Urgentes
  criticalAlerts: AnomalyAlert[]
  
  // üë§ Clientes de Alto Riesgo
  highRiskClients: Array<{
    clientId: string
    clientName: string
    riskScore: number
    riskLevel: string
    totalAnomalies: number
    anomalyRate: number
    patterns: string[]
    lastIncident: Date
    favoredByEmployees: string[]
  }>
  
  // üë®‚Äç‚öïÔ∏è Empleados Sospechosos
  suspiciousEmployees: Array<{
    employeeId: string
    employeeName: string
    riskScore: number
    riskLevel: string
    anomalyRate: number
    efficiency: number
    favoredClients: string[]
    fraudIndicators: string[]
  }>
  
  // üîó Posibles Colusiones
  collusionAlerts: Array<{
    employeeId: string
    employeeName: string
    clientId: string
    clientName: string
    sharedIncidents: number
    riskScore: number
    pattern: string
  }>
}
```

---

## üìà **M√âTRICAS Y REPORTES**

### **KPIs del Sistema**

- **Tasa de Detecci√≥n**: % de anomal√≠as detectadas vs total de servicios
- **Precisi√≥n de Alertas**: % de alertas que resultan en acciones correctivas
- **Tiempo de Respuesta**: Tiempo promedio desde detecci√≥n hasta resoluci√≥n
- **Reducci√≥n de Anomal√≠as**: Tendencia de anomal√≠as despu√©s de intervenciones

### **Reportes Autom√°ticos**

- **Reporte Semanal**: Resumen de nuevas alertas y tendencias
- **Reporte Mensual**: An√°lisis de patrones y efectividad de intervenciones
- **Reporte de Intervenci√≥n**: Seguimiento post-acci√≥n correctiva

---

## üîß **IMPLEMENTACI√ìN T√âCNICA**

### **Archivos a Crear/Modificar**

```
üìÅ lib/energy/
‚îú‚îÄ‚îÄ anomaly-scoring.ts              (NUEVO - L√≥gica de scoring)
‚îú‚îÄ‚îÄ usage-finalizer.ts              (MODIFICAR - Eliminar perfiles cliente/empleado)

üìÅ app/api/internal/
‚îú‚îÄ‚îÄ anomaly-scores/
‚îÇ   ‚îú‚îÄ‚îÄ route.ts                    (NUEVO - API principal)
‚îÇ   ‚îú‚îÄ‚îÄ clients/route.ts            (NUEVO - Scores de clientes)
‚îÇ   ‚îú‚îÄ‚îÄ employees/route.ts          (NUEVO - Scores de empleados)
‚îÇ   ‚îî‚îÄ‚îÄ alerts/route.ts             (NUEVO - Sistema de alertas)

üìÅ components/energy-insights/
‚îú‚îÄ‚îÄ anomaly-dashboard.tsx           (NUEVO - Dashboard principal)
‚îú‚îÄ‚îÄ client-risk-table.tsx          (NUEVO - Tabla clientes riesgo)
‚îú‚îÄ‚îÄ employee-risk-table.tsx        (NUEVO - Tabla empleados riesgo)
‚îî‚îÄ‚îÄ alert-notifications.tsx        (NUEVO - Notificaciones)

üìÅ prisma/
‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îî‚îÄ‚îÄ xxx_anomaly_scoring_tables.sql (NUEVO - Tablas de scoring)
‚îî‚îÄ‚îÄ schema.prisma                   (MODIFICAR - A√±adir nuevas tablas)
```

### **Variables Cr√≠ticas del Sistema**

- **systemId**: Aislamiento multi-tenant obligatorio
- **clinicId**: Segmentaci√≥n por cl√≠nica
- **riskScore**: Puntuaci√≥n 0-100 de riesgo
- **anomalyRate**: Porcentaje de servicios con anomal√≠as
- **suspiciousPatterns**: JSON con patrones detectados
- **favoredClients/favoredByEmployees**: JSON con relaciones sospechosas

---

## üéØ **PR√ìXIMOS PASOS**

### **Fase 1: Migraci√≥n (1-2 d√≠as)**
1. ‚úÖ Crear tablas de scoring de anomal√≠as
2. ‚úÖ Modificar usage-finalizer.ts
3. ‚úÖ Eliminar perfiles energ√©ticos de clientes/empleados
4. ‚úÖ Migrar datos existentes

### **Fase 2: APIs y L√≥gica (2-3 d√≠as)**
1. ‚è≥ Implementar algoritmos de scoring
2. ‚è≥ Crear APIs de consulta
3. ‚è≥ Sistema de alertas autom√°ticas
4. ‚è≥ Detecci√≥n de patrones cruzados

### **Fase 3: Dashboard (2-3 d√≠as)**
1. ‚è≥ Dashboard principal de anomal√≠as
2. ‚è≥ Tablas de riesgo de clientes/empleados
3. ‚è≥ Sistema de notificaciones
4. ‚è≥ Reportes autom√°ticos

### **Fase 4: Optimizaci√≥n (1-2 d√≠as)**
1. ‚è≥ Ajuste de algoritmos basado en datos reales
2. ‚è≥ Optimizaci√≥n de consultas
3. ‚è≥ Documentaci√≥n final
4. ‚è≥ Testing exhaustivo

---

## üìö **REFERENCIAS**

- **Algoritmos de Detecci√≥n**: Basados en an√°lisis estad√≠stico y machine learning
- **Patrones de Comportamiento**: Investigaci√≥n en detecci√≥n de anomal√≠as en servicios
- **Scoring Systems**: Metodolog√≠as de credit scoring adaptadas a servicios

---

**Documentaci√≥n actualizada**: `{new Date().toISOString()}`  
**Versi√≥n**: `2.0.0 - Sistema de Scoring Optimizado`  
**Autor**: Sistema de Documentaci√≥n Autom√°tica 