// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client-js"
  output          = "../node_modules/.prisma/client" // <<< AÑADIR ESTA LÍNEA
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL") // Usado por el cliente en runtime (Pooler)
  relationMode = "prisma"
  directUrl    = env("DIRECT_URL") // Usado por Prisma Migrate (Directa)
}

// --- Multi-Tenant Setup ---
// Tabla central para identificar cada Sistema/Tenant/Cliente del SaaS
model System {
  id        String   @id @default(cuid()) // Identificador único para cada sistema
  name      String // Nombre del sistema/cliente
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones Inversas
  users                    User[]
  clinics                  Clinic[]
  roles                    Role[]
  companies                Company[]
  contactPersons           ContactPerson[]
  leads                    Lead[]
  clients                  Client[]
  employmentContracts      EmploymentContract[]
  timeLogs                 TimeLog[]
  banks                    Bank[] // <<< NUEVO
  bankAccounts             BankAccount[]
  paymentMethodDefinitions PaymentMethodDefinition[] // <<< NUEVO
  posTerminals             PosTerminal[]
  devices                  Device[]
  equipment                Equipment[]
  appointments             Appointment[]
  scheduleTemplates        ScheduleTemplate[]
  services                 Service[]
  products                 Product[]
  stockLedgers             StockLedger[]
  vatTypes                 VATType[]
  tariffs                  Tariff[]
  tickets                  Ticket[]
  invoices                 Invoice[] // <<< NUEVO
  payments                 Payment[]
  cashSessions             CashSession[]
  bonoDefinitions          BonoDefinition[]
  bonoInstances            BonoInstance[]
  packageDefinitions       PackageDefinition[]
  packageInstances         PackageInstance[] // <<< NUEVO
  promotions               Promotion[]
  promotionCompatibilities PromotionCompatibility[] // <<< DESCOMENTADO
  skills                   Skill[]
  loyaltyLedgers           LoyaltyLedger[]
  entityImages             EntityImage[]
  entityDocuments          EntityDocument[]
  categories               Category[]
  cabins                   Cabin[]
  // templateAssignments ClinicTemplateAssignment[] // <<< ELIMINAR RELACIÓN INVERSA

  // >>> AÑADIR RELACIÓN INVERSA FALTANTE <<<
  clinicPaymentSettings ClinicPaymentSetting[]

  @@map("systems")
}

// --- Modelos de la Aplicación (Se definirán en Fase 1) ---

// Modelo para los usuarios del sistema (empleados, administradores)
model User {
  id              String   @id @default(cuid())
  email           String   @unique // Email único global y obligatorio
  firstName       String
  lastName        String? // <<< CAMBIADO A OPCIONAL
  login           String?  @unique // Nombre de usuario para login, opcional y único
  passwordHash    String // Almacenar el hash de la contraseña
  profileImageUrl String? // URL a la imagen de perfil, opcional
  phone           String? // Teléfono principal
  phone2          String? // <<< AÑADIDO: Teléfono alternativo
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // --- Relación con CountryInfo (País GENERAL del usuario) --- 
  countryIsoCode String? // Código ISO del país de residencia/principal
  country        CountryInfo? @relation(fields: [countryIsoCode], references: [isoCode], onDelete: SetNull)
  // --- Fin Relación --- 

  // --- NUEVOS: ISO Codes específicos para teléfonos --- 
  phone1CountryIsoCode String? // Código ISO del país para phone
  phone2CountryIsoCode String? // Código ISO del país para phone2
  // --- FIN NUEVOS --- 

  // --- NUEVO: Idioma preferido --- 
  languageIsoCode String? // ej: "es", "en" 
  // --- FIN NUEVO: Idioma --- 

  // Relación con System
  systemId String
  system   System @relation(fields: [systemId], references: [id], onDelete: Cascade)

  // Relaciones Inversas (Corregidas y Añadidas)
  roles                    UserRole[]
  timeLogs                 TimeLog[]
  contracts                EmploymentContract[]
  assignedLeads            Lead[]
  appointmentsAsProf       Appointment[]                 @relation("ProfessionalUserAppointments")
  ticketsAsCashier         Ticket[]                      @relation("CashierUserTickets")
  paymentsRegistered       Payment[]
  cashSessionsOpened       CashSession[]
  loyaltyAdjustments       LoyaltyLedger[]
  stockAdjustments         StockLedger[]
  skills                   UserSkill[]
  imagesUploaded           EntityImage[]                 @relation("UploadedImages")
  documentsUploaded        EntityDocument[]              @relation("UploadedDocuments")
  clinicAssignments        UserClinicAssignment[] // << AÑADIR RELACIÓN INVERSA
  // Relaciones inversas para horarios/excepciones personalizadas
  customSchedules          UserClinicSchedule[]
  customScheduleExceptions UserClinicScheduleException[]
  // <<< NUEVA RELACIÓN INVERSA PARA VENDEDOR >>>
  ticketsAsSeller          Ticket[]                      @relation("SellerUserTickets")

  @@index([systemId])
  @@index([countryIsoCode]) // Añadir índice para la nueva FK
  @@index([languageIsoCode]) // <<< AÑADIR ÍNDICE
  @@index([phone1CountryIsoCode]) // <<< AÑADIR ÍNDICE
  @@index([phone2CountryIsoCode]) // <<< AÑADIR ÍNDICE
  @@map("users")
}

// --- NUEVO MODELO: Información de Países ---
model CountryInfo {
  isoCode        String   @id @unique // Código ISO 3166-1 alpha-2 (ej: "ES", "FR")
  name           String // Nombre del país (ej: "España", "Francia")
  timezone       String // Identificador de zona horaria IANA (ej: "Europe/Madrid")
  phoneCode      String // Código telefónico internacional (ej: "+34", "+33")
  languageCode   String? // Código ISO 639-1 del idioma principal (ej: "es", "fr") <<< AÑADIDO DE NUEVO
  languageName   String? // Nombre del idioma principal (ej: "Español", "Francés") <<< AÑADIDO DE NUEVO
  // --- NUEVOS CAMPOS DE MONEDA (Making Mandatory Again) ---
  currencyCode   String // Código ISO 4217 (ej: "EUR", "USD") <-- Volver a Obligatorio
  currencyName   String // Nombre de la moneda (ej: "Euro", "US Dollar") <-- Volver a Obligatorio
  currencySymbol String // Símbolo de la moneda (ej: "€", "$") <-- Volver a Obligatorio
  // --- FIN NUEVOS CAMPOS DE MONEDA ---
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relaciones inversas
  users     User[]
  clinics   Clinic[]
  banks     Bank[] // Relación inversa con bancos
  // <<< AÑADIR RELACIÓN INVERSA FALTANTE >>>
  companies Company[] // Para Company.country
  clients   Client[] // Para Client.country

  @@index([currencyCode]) // <-- Añadir índice para moneda
  @@map("country_info")
}

// --- FIN NUEVO MODELO ---

// --- Modelo Clínica ---

model Clinic {
  id         String   @id @default(cuid())
  name       String
  address    String?
  city       String?
  postalCode String?
  province   String?
  // countryCode String? // REEMPLAZADO por relación
  // timezone    String? // REEMPLAZADO por relación (se obtiene de CountryInfo)
  currency   String // Código ISO de la moneda (ej: "EUR") // <<< MANTENER AUNQUE SE PUEDA DERIVAR DE COUNTRY, ÚTIL PARA CONTEXTO RÁPIDO
  phone      String?
  email      String?
  isActive   Boolean  @default(true)
  systemId   String
  system     System   @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // --- Relación con CountryInfo --- 
  countryIsoCode String?
  country        CountryInfo? @relation(fields: [countryIsoCode], references: [isoCode], onDelete: SetNull)
  // --- Fin Relación --- 

  // --- NUEVO: Idioma preferido --- 
  languageIsoCode String? // ej: "es", "en" 
  // --- FIN NUEVO: Idioma --- 

  // --- CAMPOS AÑADIDOS/MODIFICADOS PARA HORARIO HÍBRIDO ---
  // ID de la plantilla vinculada (si existe). Si es null, el horario es independiente.
  linkedScheduleTemplateId String?
  linkedScheduleTemplate   ScheduleTemplate? @relation("LinkedClinicTemplate", fields: [linkedScheduleTemplateId], references: [id], onDelete: SetNull)

  // Bloques específicos de esta clínica si NO está vinculada a una plantilla
  independentScheduleBlocks ClinicScheduleBlock[] // Relación mantenida para horario independiente

  // --- FIN CAMPOS HORARIO HÍBRIDO ---

  // --- CAMPOS AÑADIDOS PARA AJUSTAR A LA UI (Mantener) ---
  prefix             String?
  commercialName     String?
  businessName       String?
  cif                String?
  phone2             String?
  initialCash        Float?
  ticketSize         String? // ej: "80mm", "58mm"
  ip                 String?
  blockSignArea      Boolean? @default(false)
  blockPersonalData  Boolean? @default(false)
  delayedPayments    Boolean? @default(false)
  affectsStats       Boolean? @default(true)
  appearsInApp       Boolean? @default(true)
  scheduleControl    Boolean? @default(false)
  professionalSkills Boolean? @default(false)
  notes              String?
  tariffId           String // <<< CAMBIADO a obligatorio
  tariff             Tariff?  @relation(fields: [tariffId], references: [id], onDelete: Restrict) // <<< CAMBIADO onDelete a Restrict
  // --- FIN CAMPOS AÑADIDOS UI ---

  // --- NUEVOS: ISO Codes específicos para teléfonos --- 
  phone1CountryIsoCode String? // Código ISO del país para phone
  phone2CountryIsoCode String? // Código ISO del país para phone2
  // --- FIN NUEVOS --- 

  // Relaciones existentes (verificar si falta alguna inversa)
  equipment              Equipment[]
  appointments           Appointment[]
  clientsOrigin          Client[]                      @relation("OriginClinic") // <<< AÑADIR NOMBRE RELACIÓN
  tickets                Ticket[]
  cashSessions           CashSession[]
  userAssignments        UserClinicAssignment[]
  cabins                 Cabin[]
  // Relaciones inversas para horarios/excepciones personalizadas de usuarios
  userSchedules          UserClinicSchedule[]
  userScheduleExceptions UserClinicScheduleException[]
  // templateAssignments  ClinicTemplateAssignment[] // <<< ELIMINAR RELACIÓN INVERSA

  // Relación inversa para bloqueos de cabina
  cabinScheduleOverrides CabinScheduleOverride[]

  // <<< NUEVA RELACIÓN CON ClinicSchedule >>>
  independentSchedule ClinicSchedule? // Relación One-to-One con la configuración general del horario independiente

  // <<< AÑADIR RELACION INVERSA PROMOCION >>>
  applicablePromotions PromotionClinicScope[] // <<< AÑADIR: Relación inversa a tabla intermedia
  // <<< FIN AÑADIR >>>

  // <<< AÑADIR RELACIÓN INVERSA >>>
  paymentSettings ClinicPaymentSetting[] // <<< AÑADIR RELACIÓN INVERSA >>>

  // <<< AÑADIR RELACIONES INVERSAS PARA ÁMBITO >>>
  availableBanks        BankClinicScope[] // Bancos específicos disponibles para esta clínica
  availableBankAccounts BankAccountClinicScope[] // Cuentas específicas disponibles para esta clínica
  availablePosTerminals PosTerminalClinicScope[] // TPVs específicos disponibles para esta clínica
  // <<< FIN AÑADIR RELACIONES INVERSAS PARA ÁMBITO >>>

  // <<< AÑADIR RELACIÓN INVERSA FALTANTE >>>
  payments Payment[] // Para Payment.clinic

  @@unique([name, systemId], name: "Clinic_name_systemId_key")
  @@index([systemId])
  @@index([tariffId]) // Añadir índice para tariffId
  @@index([linkedScheduleTemplateId]) // Añadir índice para la nueva FK
  @@index([countryIsoCode]) // Añadir índice para la nueva FK
  @@index([languageIsoCode]) // <<< AÑADIR ÍNDICE
  @@index([phone1CountryIsoCode]) // <<< AÑADIR ÍNDICE
  @@index([phone2CountryIsoCode]) // <<< AÑADIR ÍNDICE
  @@map("clinics")
}

// --- Modelos RBAC (Role-Based Access Control) ---

model Role {
  id          String   @id @default(cuid())
  name        String // Nombre del rol (ej: "Administrador", "Personal Clínica")
  description String? // Descripción opcional del rol
  systemId    String // A qué sistema pertenece este rol
  system      System   @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relaciones
  users             UserRole[] // Usuarios que tienen este rol
  permissions       RolePermission[] // Permisos asociados a este rol
  clinicAssignments UserClinicAssignment[] // << AÑADIR INVERSA para asignaciones por clínica

  @@unique([name, systemId]) // El nombre del rol debe ser único dentro de un sistema
  @@index([systemId])
  @@map("roles")
}

model Permission {
  id          String   @id @default(cuid())
  action      String // Acción específica (ej: "crear", "leer", "actualizar", "eliminar", "bloquear_agenda")
  module      String // Módulo al que pertenece (ej: "cita", "cliente", "agenda")
  description String? // Descripción opcional del permiso
  createdAt   DateTime @default(now())

  // Relación
  roles RolePermission[] // Roles que incluyen este permiso

  @@unique([action, module]) // La combinación acción/módulo debe ser única
  @@map("permissions")
}

// Tabla de unión para la relación Muchos-a-Muchos entre User y Role
model UserRole {
  userId     String
  roleId     String
  assignedAt DateTime @default(now())

  // Relaciones
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId]) // Clave primaria compuesta
  @@index([userId])
  @@index([roleId])
  @@map("user_roles")
}

// Tabla de unión para la relación Muchos-a-Muchos entre Role y Permission
model RolePermission {
  roleId       String
  permissionId String
  assignedAt   DateTime @default(now())

  // Relaciones
  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId]) // Clave primaria compuesta
  @@index([roleId])
  @@index([permissionId])
  @@map("role_permissions")
}

// --- Modelos Empresa/Contacto ---

model Company {
  id               String          @id @default(cuid())
  fiscalName       String // Razón Social
  taxId            String          @unique // CIF/NIF único por sistema
  address          String?
  city             String?
  postalCode       String?
  countryIsoCode   String? // Código ISO del país
  country          CountryInfo?    @relation(fields: [countryIsoCode], references: [isoCode])
  phone            String?
  email            String?         @unique // Email único por sistema
  website          String?
  notes            String?
  systemId         String
  system           System          @relation(fields: [systemId], references: [id], onDelete: Cascade)
  contactPersons   ContactPerson[] // Personas de contacto asociadas
  leads            Lead[] // Leads asociados a esta compañía
  clients          Client[] // Clientes asociados a esta compañía
  purchaseInvoices Invoice[]       @relation("PurchaseInvoices") // Facturas de COMPRA recibidas de esta compañía (como proveedor)
  // <<< CORREGIR: Usar el nombre de relación correcto >>>
  payerPayments    Payment[]       @relation("PayerCompanyPayments")
  // <<< AÑADIR RELACIONES INVERSAS FALTANTES >>>
  saleInvoices     Invoice[]       @relation("SaleInvoices") // Para Invoice.company
  tickets          Ticket[] // Para Ticket.company

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([taxId, systemId])
  @@index([systemId])
  @@index([countryIsoCode])
}

model ContactPerson {
  id        String   @id @default(cuid())
  firstName String
  lastName  String
  position  String? // Cargo (ej: "Gerente Compras")
  email     String? // Email del contacto (puede ser único si se desea)
  phone     String?
  notes     String?
  companyId String // A qué empresa pertenece
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  systemId  String // A qué sistema pertenece (derivado de Company? O explícito?)
  system    System   @relation(fields: [systemId], references: [id], onDelete: Cascade) // Mantener por si un contacto se mueve o por consistencia
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([systemId])
  @@map("contact_persons")
}

// --- Modelo CRM (Leads/Presuntos) ---

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  CONVERTED // Se convirtió en Client/Company
  LOST
}

model Lead {
  id               String     @id @default(cuid())
  firstName        String?
  lastName         String?
  email            String?
  phone            String?
  companyName      String? // Si el lead es B2B
  source           String? // Origen del lead (ej: "Web", "Referido", "Campaña X")
  status           LeadStatus @default(NEW)
  notes            String?
  assignedToUserId String? // ID del User (empleado) asignado
  assignedToUser   User?      @relation(fields: [assignedToUserId], references: [id], onDelete: SetNull) // Relación opcional con User
  systemId         String // A qué sistema pertenece este lead
  system           System     @relation(fields: [systemId], references: [id], onDelete: Cascade)
  // <<< AÑADIR RELACIÓN INVERSA FALTANTE >>>
  companyId        String? // Para Company.leads
  company          Company?   @relation(fields: [companyId], references: [id], onDelete: SetNull) // Relación opcional

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Índices para búsquedas comunes
  @@index([status])
  @@index([assignedToUserId])
  @@index([systemId])
  @@index([companyId]) // <<< AÑADIR ÍNDICE
  @@map("leads")
}

// --- Modelo Cliente Final (Persona Física) ---

model Client {
  id                           String       @id @default(cuid())
  firstName                    String
  lastName                     String
  email                        String? // Email (opcional, podría no ser único globalmente)
  phone                        String? // Teléfono principal
  phoneCountryIsoCode          String? // Código ISO del país para el teléfono principal
  secondaryPhone               String? // Teléfono secundario
  secondaryPhoneCountryIsoCode String? // Código ISO para el teléfono secundario
  birthDate                    DateTime? // Fecha de nacimiento
  gender                       String? // Género (ej: 'Male', 'Female', 'Other', 'Prefer not to say')
  address                      String?
  city                         String?
  postalCode                   String?
  countryIsoCode               String? // Código ISO del país de residencia
  country                      CountryInfo? @relation(fields: [countryIsoCode], references: [isoCode])
  nationalId                   String? // DNI/NIE/Pasaporte
  fiscalName                   String? // Razón social (si es empresa/autónomo)
  taxId                        String? // NIF/CIF (si aplica)
  notes                        String?
  marketingConsent             Boolean      @default(false) // Consentimiento para marketing
  dataProcessingConsent        Boolean      @default(false) // Consentimiento tratamiento de datos
  isActive                     Boolean      @default(true)
  systemId                     String
  system                       System       @relation(fields: [systemId], references: [id], onDelete: Cascade)
  companyId                    String? // Opcional: ID de la empresa a la que pertenece el cliente
  company                      Company?     @relation(fields: [companyId], references: [id])
  // <<< AÑADIR RELACIÓN INVERSA FALTANTE >>>
  originClinicId               String? // Para Clinic.clientsOrigin
  originClinic                 Clinic?      @relation("OriginClinic", fields: [originClinicId], references: [id], onDelete: SetNull)

  appointments        Appointment[] // Citas del cliente
  tickets             Ticket[] // Tickets del cliente
  invoices            Invoice[] // Facturas del cliente (como receptor)
  timeLogs            TimeLog[] // Registros de tiempo (si es empleado)
  relationsAsSource   ClientRelation[]     @relation("ClientA") // <<< CAMBIADO NOMBRE RELACIÓN por el de ClientRelation
  relationsAsTarget   ClientRelation[]     @relation("ClientB") // <<< CAMBIADO NOMBRE RELACIÓN por el de ClientRelation
  employmentContracts EmploymentContract[] // Contratos laborales (si es empleado)
  bonoInstances       BonoInstance[] // Bonos activos del cliente
  packageInstances    PackageInstance[] // Paquetes activos del cliente
  loyaltyLedgers      LoyaltyLedger[] // Añadido inverso para LoyaltyLedger
  // <<< CORREGIR: Usar el nombre de relación correcto >>>
  payerPayments       Payment[]            @relation("PayerClientPayments")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([systemId])
  @@index([companyId])
  @@index([countryIsoCode])
  @@index([lastName]) // Índice común para búsquedas por apellido
  @@index([email]) // Índice si se busca frecuentemente por email
  @@index([phone]) // Índice si se busca frecuentemente por teléfono
  @@index([originClinicId]) // <<< AÑADIR ÍNDICE
}

// Tabla de unión explícita para la relación Muchos-a-Muchos reflexiva de Client
model ClientRelation {
  clientAId    String
  clientBId    String
  relationType String // Tipo de relación (ej: "MADRE_HIJA", "TUTOR_LEGAL", "CONTACTO_EMERGENCIA")
  notes        String?
  createdAt    DateTime @default(now())

  // Relaciones
  clientA Client @relation("ClientA", fields: [clientAId], references: [id], onDelete: Cascade)
  clientB Client @relation("ClientB", fields: [clientBId], references: [id], onDelete: Cascade)
  // <<< ELIMINAR RELACIONES INVERSAS DUPLICADAS/INCORRECTAS >>>
  // relationsAsSource Client[] @relation("SourceClient") // Incorrecto
  // relationsAsTarget Client[] @relation("TargetClient") // Incorrecto

  @@id([clientAId, clientBId]) // Clave primaria compuesta
  @@index([clientAId])
  @@index([clientBId])
  @@map("client_relations")
}

// --- Modelos Datos Empleado (User) ---

model EmploymentContract {
  id           String    @id @default(cuid())
  userId       String // A qué User pertenece este contrato
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  contractType String? // Tipo de contrato (ej: "Indefinido", "Temporal", "Prácticas")
  startDate    DateTime
  endDate      DateTime? // Fecha de fin, si aplica
  jobTitle     String? // Puesto de trabajo
  salaryInfo   String? // Información salarial (Texto plano, encriptado, o referencia a otro sistema? Por ahora texto)
  details      String? // Otros detalles o cláusulas
  documentUrl  String? // URL al documento del contrato escaneado (opcional)
  systemId     String // A qué sistema pertenece (redundante con User.systemId, pero útil para queries directas)
  system       System    @relation(fields: [systemId], references: [id], onDelete: Cascade)
  // <<< AÑADIR RELACIÓN INVERSA FALTANTE >>>
  clientId     String? // Para Client.employmentContracts
  client       Client?   @relation(fields: [clientId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([systemId])
  @@index([clientId]) // <<< AÑADIR ÍNDICE
  @@map("employment_contracts")
}

model TimeLog {
  id              String    @id @default(cuid())
  userId          String // A qué User pertenece este fichaje
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  clockInTime     DateTime // Hora de entrada
  clockOutTime    DateTime? // Hora de salida (opcional hasta que se ficha)
  date            DateTime  @db.Date // La fecha del fichaje (solo día)
  durationMinutes Int? // Duración calculada en minutos (opcional, se puede calcular al vuelo o al fichar salida)
  notes           String?
  source          String? // Origen del fichaje (ej: "WEB", "APP_MOVIL", "KIOSK")
  systemId        String // A qué sistema pertenece
  system          System    @relation(fields: [systemId], references: [id], onDelete: Cascade)
  // <<< AÑADIR RELACIÓN INVERSA FALTANTE >>>
  clientId        String? // Para Client.timeLogs
  client          Client?   @relation(fields: [clientId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, date]) // Índice común para buscar fichajes de un usuario en un día
  @@index([userId])
  @@index([systemId])
  @@index([clientId]) // <<< AÑADIR ÍNDICE
  @@map("time_logs")
}

// --- Modelos Financieros Base ---

// <<< NUEVO MODELO: Banco >>>
model Bank {
  id                   String  @id @default(cuid())
  name                 String
  code                 String?
  phone                String?
  phone1CountryIsoCode String? // Código ISO país para phone
  phone2               String?
  phone2CountryIsoCode String? // Código ISO país para phone2
  email                String?
  address              String?
  isGlobal             Boolean @default(true) // Ámbito global o específico
  systemId             String
  countryIsoCode       String? // Opcional, para relacionar con CountryInfo

  system  System       @relation(fields: [systemId], references: [id], onDelete: Cascade)
  country CountryInfo? @relation(fields: [countryIsoCode], references: [isoCode])

  // Relaciones inversas
  bankAccounts      BankAccount[] // <<< AÑADIDO CAMPO INVERSO
  applicableClinics BankClinicScope[] // Clínicas específicas donde está disponible

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, systemId])
  @@index([systemId])
  @@index([countryIsoCode])
}

// <<< NUEVO MODELO: Tabla Intermedia Banco-Clínica >>>
model BankClinicScope {
  bankId   String
  clinicId String

  bank   Bank   @relation(fields: [bankId], references: [id], onDelete: Cascade)
  clinic Clinic @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  @@id([bankId, clinicId])
  @@index([clinicId]) // Índice para buscar bancos por clínica
  @@map("bank_clinic_scopes")
}

// <<< FIN NUEVO MODELO >>>

model BankAccount {
  id          String  @id @default(cuid())
  accountName String
  iban        String  @unique // IBAN debe ser único
  swiftBic    String? // Opcional
  currency    String  @default("EUR")
  notes       String?
  isActive    Boolean @default(true)
  isGlobal    Boolean @default(true) // Ámbito Global por defecto

  // Relaciones
  systemId String
  bankId   String // Banco al que pertenece

  system       System        @relation(fields: [systemId], references: [id], onDelete: Cascade)
  bank         Bank          @relation(fields: [bankId], references: [id], onDelete: Cascade)
  posTerminals PosTerminal[] // TPVs que liquidan en esta cuenta
  payments     Payment[] // Pagos directos asociados a esta cuenta (ej. transferencias)

  // Relación para el ámbito de clínicas
  applicableClinics BankAccountClinicScope[]

  // <<< AÑADIR RELACIÓN INVERSA >>>
  clinicPaymentSettings ClinicPaymentSetting[] @relation("BankAccountSettings") // Configuraciones de pago que usan esta cuenta

  // Constraints
  @@unique([accountName, bankId, systemId]) // Nombre único por banco y sistema
  @@index([bankId])
  @@index([systemId])
}

// >>> NUEVO MODELO: Tabla intermedia para BankAccount <-> Clinic <<<
model BankAccountClinicScope {
  bankAccountId String
  clinicId      String

  bankAccount BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  clinic      Clinic      @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@id([bankAccountId, clinicId]) // Clave primaria compuesta
  @@index([bankAccountId])
  @@index([clinicId])
}

// <<< NUEVO ENUM: Tipo de Método de Pago >>>
enum PaymentMethodType {
  CASH // Efectivo
  CARD // Tarjeta (genérico, TPV)
  BANK_TRANSFER // Transferencia bancaria
  ONLINE_GATEWAY // Pasarela online (Stripe, PayPal, etc.)
  CHECK // Cheque bancario
  INTERNAL_CREDIT // Crédito interno, Bono, Paquete, Puntos
  OTHER // Otro
}

// <<< NUEVO MODELO: Definición Método de Pago >>>
model PaymentMethodDefinition {
  id       String @id @default(cuid()) // <<< Cambiado a cuid()
  systemId String // <<< Sin @db.ObjectId
  system   System @relation(fields: [systemId], references: [id], onDelete: Cascade)

  name     String
  type     PaymentMethodType // CASH, CARD, BANK_TRANSFER, INTERNAL_CREDIT, etc.
  details  String?
  isActive Boolean           @default(true)

  // Relación con la nueva tabla de configuración por clínica
  clinicSettings ClinicPaymentSetting[]

  // Relación con pagos realizados (no cambia)
  payments Payment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Asegurar índice único global
  @@unique([name, systemId])
  @@index([systemId])
  // <<< AÑADIR MAP >>>
  @@map("payment_method_definitions")
}

// <<< FIN NUEVO MODELO >>>

model PosTerminal {
  id                 String  @id @default(cuid())
  name               String // Nombre identificativo del TPV (ej: "TPV Mostrador")
  terminalIdProvider String? // ID o referencia asignada por el proveedor (ej: ID de Stripe Terminal)
  provider           String? // Proveedor del TPV (ej: "Redsys", "Stripe", "Adyen")
  modelNumber        String? // Número de modelo del dispositivo físico (opcional)
  serialNumber       String? // Número de serie del dispositivo físico (opcional)
  ipAddress          String? // Dirección IP (si es relevante)
  notes              String?
  isActive           Boolean @default(true)
  // <<< AÑADIDO isGlobal >>>
  isGlobal           Boolean @default(true) // Ámbito Global por defecto

  // Relaciones
  systemId      String
  bankAccountId String? // Cuenta bancaria donde se liquidan los pagos (puede ser opcional si el TPV no liquida directamente)
  // <<< ELIMINADO clinicId directo >>>

  system      System       @relation(fields: [systemId], references: [id], onDelete: Cascade)
  bankAccount BankAccount? @relation(fields: [bankAccountId], references: [id])
  payments    Payment[] // Pagos realizados a través de este TPV

  // Relación para configuraciones de pago específicas por clínica que usan este TPV
  clinicPaymentSettings ClinicPaymentSetting[] @relation("PosTerminalSettings")

  // Relación para el ámbito de clínicas
  applicableClinics PosTerminalClinicScope[]

  // Constraints
  @@unique([name, systemId]) // Nombre único por sistema
  @@index([bankAccountId])
  // <<< ELIMINADO ÍNDICE clinicId >>>
  // @@index([clinicId]) 
  @@index([systemId])
  // Mapeo explícito a nombre de tabla snake_case
  @@map("pos_terminals")
}

// <<< AÑADIR DEFINICIÓN DE PosTerminalClinicScope >>>
model PosTerminalClinicScope {
  posTerminalId String
  clinicId      String
  posTerminal   PosTerminal @relation(fields: [posTerminalId], references: [id], onDelete: Cascade)
  clinic        Clinic      @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  @@id([posTerminalId, clinicId])
  @@index([clinicId]) // Añadir índices es buena práctica
  @@map("pos_terminal_clinic_scopes")
}

// <<< FIN DEFINICIÓN >>>

// --- Modelo Dispositivo Inteligente (Anti-Fraude) ---

enum DeviceStatus {
  ONLINE
  OFFLINE
  ERROR
}

// --- Modelo Equipamiento ---

model Equipment {
  id              String    @id @default(cuid())
  name            String // Nombre del equipo (ej: "Láser Diodo A")
  description     String?
  serialNumber    String?   @unique // Número de serie, si aplica y es único
  modelNumber     String?
  purchaseDate    DateTime?
  warrantyEndDate DateTime?
  location        String? // Ubicación específica dentro de la clínica (ej: "Sala 3")
  notes           String?
  isActive        Boolean   @default(true)
  systemId        String // A qué sistema pertenece
  system          System    @relation(fields: [systemId], references: [id], onDelete: Cascade)
  clinicId        String? // A qué clínica pertenece
  clinic          Clinic?   @relation(fields: [clinicId], references: [id], onDelete: SetNull)

  // Relación con el Dispositivo Inteligente que lo controla (opcional)
  deviceId String? @unique // Un dispositivo controla un solo equipo
  device   Device? @relation(fields: [deviceId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones
  appointmentsUsing Appointment[] // Citas que usan este equipo específico

  // <<< NUEVA RELACIÓN INVERSA >>>
  requiredByServices ServiceEquipmentRequirement[]

  @@unique([name, systemId])
  @@index([systemId])
  @@index([clinicId]) // Añadir índice por clinicId
  @@index([deviceId])
  @@map("equipment")
}

model Device {
  id               String        @id @default(cuid())
  name             String // Nombre descriptivo (ej: "Enchufe Láser Sala 1")
  deviceIdProvider String?       @unique // ID único del fabricante/API (MAC, ID Cloud), único globalmente?
  deviceType       String? // Tipo de dispositivo (ej: "SMART_PLUG", "LASER_MACHINE_API")
  apiEndpoint      String? // URL o identificador para interactuar con la API del dispositivo
  lastKnownStatus  DeviceStatus? // Último estado conocido (podría actualizarse por un servicio externo)
  notes            String?
  systemId         String // A qué sistema pertenece
  system           System        @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  // Relaciones
  equipmentControlled Equipment? // El equipo que controla este dispositivo (relación One-to-One)

  @@index([systemId])
  @@index([deviceIdProvider])
  @@map("devices")
}

// --- Modelo Cita (Appointment) ---

enum AppointmentStatus {
  SCHEDULED // Agendada
  CONFIRMED // Confirmada por cliente/sistema
  CHECKED_IN // Cliente ha llegado
  IN_PROGRESS // En curso (opcional, si se quiere marcar)
  COMPLETED // Completada
  CANCELLED // Cancelada (por cliente o clínica)
  NO_SHOW // No presentado
  LOCKED // Bloqueada por uso de dispositivo (anti-fraude)
}

model Appointment {
  id              String            @id @default(cuid())
  startTime       DateTime // Hora de inicio
  endTime         DateTime // Hora de fin (calculada o fijada)
  durationMinutes Int // Duración en minutos (calculada a partir de los servicios)
  status          AppointmentStatus @default(SCHEDULED)
  notes           String? // Notas internas sobre la cita
  clientNotes     String? // Notas o peticiones del cliente al reservar

  // Relaciones Clave
  clientId           String
  client             Client @relation(fields: [clientId], references: [id])
  professionalUserId String // ID del User (profesional) que realiza el servicio
  professionalUser   User   @relation("ProfessionalUserAppointments", fields: [professionalUserId], references: [id])
  systemId           String
  system             System @relation(fields: [systemId], references: [id], onDelete: Cascade)
  clinicId           String // Clínica donde se realiza
  clinic             Clinic @relation(fields: [clinicId], references: [id])

  // Relación con Equipo (para anti-fraude y tracking)
  equipmentId String? // Equipo específico utilizado (opcional si no aplica)
  equipment   Equipment? @relation(fields: [equipmentId], references: [id], onDelete: SetNull)

  // Campos Anti-Fraude (Dispositivo Inteligente)
  deviceActivationTimestamp   DateTime? // Hora real de encendido del dispositivo
  deviceDeactivationTimestamp DateTime? // Hora real de apagado del dispositivo
  actualUsageMinutes          Int? // Minutos reales de uso del dispositivo
  isUsageLocked               Boolean   @default(false) // Bloqueada si el dispositivo se usó

  // Otros campos
  originalAppointmentId String? // Para citas reagendadas, apunta a la original
  // tickets               Ticket[] // <<< MOVIDO a Relación Many-to-Many (Un Ticket puede tener múltiples citas?) --> No, se queda aquí (Una cita puede generar UN ticket de venta)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relación inversa con Ticket (Una cita puede generar UN ticket)
  relatedTicket Ticket?

  @@index([startTime])
  @@index([clientId])
  @@index([professionalUserId])
  @@index([systemId])
  @@index([clinicId]) // Añadir índice por clinicId
  @@index([equipmentId])
  @@index([status])
  @@index([originalAppointmentId])
  @@map("appointments")
}

// --- Modelos Horarios y Excepciones ---

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum ExceptionType {
  HOLIDAY // Festivo
  VACATION // Vacaciones empleado
  LEAVE // Baja médica/Permiso
  SPECIAL_CLOSURE // Cierre excepcional clínica
  SPECIAL_OPENING // Apertura excepcional
  OTHER
}

enum ExceptionScope {
  USER
  CLINIC
  SYSTEM // Aplica a todo el sistema (ej: festivo nacional)
}

// Plantilla de Horario reutilizable
model ScheduleTemplate {
  id            String                  @id @default(cuid())
  name          String // Ej: "Lunes a Viernes (Mañanas)", "Horario Verano"
  description   String? // Descripción opcional
  systemId      String
  system        System                  @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt     DateTime                @default(now())
  updatedAt     DateTime                @updatedAt
  openTime      String? // Formato HH:MM (Mantenido en plantilla)
  closeTime     String? // Formato HH:MM (Mantenido en plantilla)
  slotDuration  Int? // (Mantenido en plantilla)
  blocks        ScheduleTemplateBlock[]
  linkedClinics Clinic[]                @relation("LinkedClinicTemplate")

  @@unique([name, systemId])
  @@index([systemId])
  @@map("schedule_templates")
}

// Bloque de tiempo dentro de una plantilla de horario
model ScheduleTemplateBlock {
  id         String           @id @default(cuid())
  templateId String
  template   ScheduleTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  dayOfWeek  DayOfWeek // Enum: MONDAY, TUESDAY, etc.
  startTime  String // Formato HH:MM
  endTime    String // Formato HH:MM
  isWorking  Boolean          @default(true)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  @@index([templateId])
  @@map("schedule_template_blocks")
}

// --- NUEVO MODELO: Configuración General del Horario Independiente de Clínica ---
model ClinicSchedule {
  id           String   @id @default(cuid())
  clinicId     String   @unique // Cada clínica tiene solo UNA configuración independiente
  clinic       Clinic   @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  openTime     String? // Formato HH:MM (Hora más temprana usada en los bloques o default)
  closeTime    String? // Formato HH:MM (Hora más tardía usada en los bloques o default)
  slotDuration Int? // Duración del slot para este horario independiente (ej: 15, 30)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([clinicId])
  @@map("clinic_schedules")
}

// --- FIN NUEVO MODELO ---

// --- NUEVO MODELO: Bloque de Horario Específico de Clínica (Independiente) ---
model ClinicScheduleBlock {
  id        String    @id @default(cuid())
  clinicId  String
  clinic    Clinic    @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  dayOfWeek DayOfWeek
  startTime String
  endTime   String
  isWorking Boolean   @default(true)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([clinicId])
  @@map("clinic_schedule_blocks")
}

// --- Modelos Catálogo (Servicios, Productos) y Stock ---

model Service {
  id                     String  @id @default(cuid())
  code                   String? // Código interno o SKU
  name                   String // Nombre del servicio
  description            String?
  durationMinutes        Int // Duración estándar del servicio
  price                  Float? // Precio base (GLOBAL)
  colorCode              String? // Color para la agenda
  // requiresMedicalSignOff Boolean @default(false) // <<< MOVER a ServiceSetting
  // pointsAwarded          Int     @default(0) // <<< MOVER a ServiceSetting
  // isActive               Boolean @default(true) // <<< MOVER a ServiceSetting
  systemId               String
  system                 System  @relation(fields: [systemId], references: [id], onDelete: Cascade)

  // Relaciones
  ticketItems        TicketItem[]
  invoiceItems       InvoiceItem[]
  bonoDefinitions    BonoDefinition[]
  includedInPackages PackageItem[]

  // Relación con Category/Familia
  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  // Relación con VATType
  vatTypeId String? // IVA base (GLOBAL)
  vatType   VATType? @relation(fields: [vatTypeId], references: [id], onDelete: SetNull)

  // Relación inversa para precios específicos por tarifa
  tariffPrices TariffServicePrice[]

  // Relación inversa para consumos globales
  consumptions ServiceConsumption[]

  // <<< NUEVA RELACIÓN 1-a-1 con ServiceSetting >>>
  settings ServiceSetting?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones Inversas Promoción
  targetedPromotions Promotion[] @relation("TargetService")
  bogoGiftPromotions Promotion[] @relation("BogoService")

  @@unique([name, systemId])
  @@index([systemId])
  @@index([categoryId])
  @@index([vatTypeId])
  @@map("services")
}

// --- NUEVO MODELO: Configuración de Servicio ---
model ServiceSetting {
  id            String  @id @default(cuid())
  serviceId     String  @unique // Clave foránea y constraint único para One-to-One
  service       Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  // Campos movidos y nuevos
  requiresMedicalSignOff Boolean @default(false) // Requiere firma médica?
  pointsAwarded          Int     @default(0) // Puntos de fidelidad otorgados
  isActive               Boolean @default(true)
  commissionType         String? // Tipo de comisión (ej: "PERCENTAGE", "FIXED")
  commissionValue        Float? // Valor de la comisión
  requiresParams         Boolean @default(false) // Necesita parámetros extra?
  appearsInApp           Boolean @default(true) // Visible en app de cliente?
  autoAddToInvoice       Boolean @default(false) // Añadir auto a factura/ticket?
  onlineBookingEnabled   Boolean @default(true) // Permite reserva online?
  minTimeBeforeBooking   Int? // Minutos antelación reserva
  maxTimeBeforeBooking   Int? // Días antelación reserva
  cancellationPolicy     String? // Política de cancelación
  preparationTimeMinutes Int? // Minutos preparación antes
  cleanupTimeMinutes     Int? // Minutos limpieza después
  internalNotes          String? // Notas internas

  // Relación con Equipamiento (Many-to-Many explícita)
  equipmentRequirements ServiceEquipmentRequirement[]

  // Relación con Habilidades (Many-to-Many explícita)
  skillRequirements ServiceSkillRequirement[]

  @@map("service_settings")
}

// --- NUEVA TABLA INTERMEDIA: Service <-> Equipment ---
model ServiceEquipmentRequirement {
  serviceId   String
  equipmentId String

  service   ServiceSetting @relation(fields: [serviceId], references: [serviceId], onDelete: Cascade)
  equipment Equipment    @relation(fields: [equipmentId], references: [id], onDelete: Cascade)

  @@id([serviceId, equipmentId])
  @@index([equipmentId]) // Índice para buscar servicios por equipo
  @@map("service_equipment_requirements")
}

// --- NUEVA TABLA INTERMEDIA: Service <-> Skill ---
model ServiceSkillRequirement {
  serviceId String
  skillId   String

  service ServiceSetting @relation(fields: [serviceId], references: [serviceId], onDelete: Cascade)
  skill   Skill        @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@id([serviceId, skillId])
  @@index([skillId]) // Índice para buscar servicios por habilidad
  @@map("service_skill_requirements")
}
// --- FIN NUEVOS MODELOS/TABLAS SERVICIO ---

model Product {
  id                String  @id @default(cuid())
  name              String
  description       String?
  sku               String? @unique
  barcode           String?
  price             Float? // Precio de venta base (GLOBAL)
  costPrice         Float? // Precio de coste (GLOBAL)
  // currentStock      Int     @default(0) // <<< MOVER a ProductSetting
  // minStockThreshold Int? // <<< MOVER a ProductSetting
  // isForSale         Boolean @default(true) // <<< MOVER a ProductSetting
  // isInternalUse     Boolean @default(false) // <<< MOVER a ProductSetting
  // isActive          Boolean @default(true) // <<< MOVER a ProductSetting
  // pointsAwarded     Int     @default(0) // <<< MOVER a ProductSetting
  systemId          String
  system            System  @relation(fields: [systemId], references: [id], onDelete: Cascade)

  // Relaciones
  stockMovements     StockLedger[]
  ticketItems        TicketItem[]
  invoiceItems       InvoiceItem[]
  includedInPackages PackageItem[]

  // Relación con Category/Familia
  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  // Relación con VATType
  vatTypeId String? // IVA base (GLOBAL)
  vatType   VATType? @relation(fields: [vatTypeId], references: [id], onDelete: SetNull)

  // Relación inversa para precios específicos por tarifa
  productPrices TariffProductPrice[]

  // Relación inversa para consumos globales
  consumptions ServiceConsumption[]

  // <<< NUEVA RELACIÓN 1-a-1 con ProductSetting >>>
  settings ProductSetting?

  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  BonoDefinition BonoDefinition[]

  // Relaciones Inversas Promoción
  targetedPromotions Promotion[] @relation("TargetProduct")
  bogoGiftPromotions Promotion[] @relation("BogoProduct")

  @@unique([name, systemId])
  @@index([systemId])
  @@index([categoryId])
  @@index([vatTypeId])
  @@map("products")
}

// --- NUEVO MODELO: Configuración de Producto ---
model ProductSetting {
  id                String  @id @default(cuid())
  productId         String  @unique // Clave foránea y constraint único para One-to-One
  product           Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Campos movidos
  currentStock      Int     @default(0)
  minStockThreshold Int?
  isForSale         Boolean @default(true)
  isInternalUse     Boolean @default(false)
  isActive          Boolean @default(true)
  pointsAwarded     Int     @default(0)

  // Otros campos de configuración específicos de producto (futuros)
  // dimensions      String?
  // weight          Float?
  // expirationRule  String?
  // ...

  @@map("product_settings")
}
// --- FIN NUEVO MODELO PRODUCTO ---

// Registro de movimientos de stock
enum StockMovementType {
  INITIAL // Carga inicial
  PURCHASE // Compra a proveedor
  SALE // Venta directa
  CONSUMPTION // Consumo en servicio <<< CORREGIDO
  ADJUSTMENT // Ajuste manual (inventario)
  TRANSFER_IN // Transferencia desde otra clínica
  TRANSFER_OUT // Transferencia a otra clínica
  RETURN_SUPPLIER // Devolución a proveedor
  RETURN_CLIENT // Devolución de cliente
}

model StockLedger {
  id           String            @id @default(cuid())
  productId    String
  product      Product           @relation(fields: [productId], references: [id])
  movementType StockMovementType
  quantity     Int // Cantidad movida (+ para entradas, - para salidas) <<< CORREGIDO
  movementDate DateTime          @default(now())
  notes        String?
  userId       String? // Usuario que realizó/registró el movimiento
  user         User?             @relation(fields: [userId], references: [id], onDelete: SetNull)
  systemId     String
  system       System            @relation(fields: [systemId], references: [id], onDelete: Cascade) // <<< CAMBIADO a Cascade
  createdAt    DateTime          @default(now())

  @@index([productId])
  @@index([movementDate])
  @@index([userId])
  @@index([systemId])
  @@map("stock_ledgers")
}

// Modelo Consumo de Producto por Servicio (Para gestión de Stock)
model ServiceConsumption {
  id        String  @id @default(cuid())
  serviceId String
  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade) // Cascade: si se borra el producto, este registro de consumo no tiene sentido
  quantity  Float // Cantidad consumida <<< CORREGIDO
  // unit      String? // Unidad (ej: "ml", "unidad", "gramo") <<< Opcional, añadir si es necesario
  order     Int // Orden de aplicación/visualización (si importa)
  notes     String? // Notas específicas para este consumo en este servicio

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([serviceId])
  @@index([productId])
  @@map("service_consumptions")
}

// --- Modelos Tarifas y Precios ---

model VATType {
  id        String  @id @default(cuid())
  name      String // Nombre (ej: "General", "Reducido")
  rate      Float // Tasa porcentual (ej: 21.0, 10.0)
  isDefault Boolean @default(false)
  systemId  String
  system    System  @relation(fields: [systemId], references: [id], onDelete: Cascade)

  // Relaciones inversas existentes
  services            Service[] // Servicios que usan este como IVA base
  products            Product[] // Productos que usan este como IVA base
  tariffs             Tariff[] // Tarifas que usan este como IVA obligatorio
  appliedTicketItems  TicketItem[]  @relation("AppliedVATType")
  originalTicketItems TicketItem[]  @relation("OriginalVATType")
  invoiceItems        InvoiceItem[] @relation("AppliedInvoiceVATType") // <<< NUEVO: Inverso para InvoiceItem

  // Relaciones inversas para precios específicos
  tariffServicePrices TariffServicePrice[]
  tariffProductPrices TariffProductPrice[]
  tariffBonoPrices    TariffBonoPrice[]
  tariffPackagePrices TariffPackagePrice[]

  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  BonoDefinition BonoDefinition[]

  @@unique([name, systemId])
  @@index([systemId])
  @@map("vat_types")
}

// Tarifa o Lista de Precios
model Tariff {
  id          String    @id @default(cuid())
  name        String // Ej: "Tarifa General 2024", "Tarifa VIP", "Tarifa Online"
  description String?
  isDefault   Boolean   @default(false) // Es la tarifa por defecto del sistema/clínica?
  validFrom   DateTime? @db.Date // Fecha desde la que es válida
  validUntil  DateTime? @db.Date // Fecha hasta la que es válida (null si indefinida)
  isActive    Boolean   @default(true)

  // Campo de IVA Específico (Obligatorio)
  vatTypeId String
  vatType   VATType @relation(fields: [vatTypeId], references: [id], onDelete: Restrict)

  // Campo de Moneda (Obligatorio)
  currencyCode String // Código ISO 4217 (ej: "EUR", "USD", "MAD")

  systemId String
  system   System @relation(fields: [systemId], references: [id], onDelete: Cascade)

  // Relación Inversa con Clinic
  clinics Clinic[]

  // Relaciones Inversas para Precios Específicos
  servicePrices TariffServicePrice[]
  productPrices TariffProductPrice[]
  bonoPrices    TariffBonoPrice[]
  packagePrices TariffPackagePrice[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relacion Inversa Promocion
  targetedPromotions Promotion[] @relation("TargetTariff")

  @@unique([name, systemId]) // Nombre único por sistema
  @@index([systemId])
  @@index([vatTypeId])
  // @@index([currencyCode]) // Índice opcional para moneda
  @@map("tariffs")
}

// --- Modelos Ventas, Pagos y Caja ---

// <<< MANTENER TicketType >>>
enum TicketType {
  SALE // Venta normal
  RETURN // Devolución/Abono operativo
}

enum TicketStatus {
  DRAFT // Borrador (presupuesto?)
  OPEN // Abierto (pendiente de pago total)
  PAID // Pagado
  PARTIALLY_PAID // Parcialmente pagado
  VOID // Anulado
  REFUNDED // Reembolsado (total o parcial)
  PARTIALLY_REFUNDED
}

// <<< ELIMINAR ENUM PaymentMethod (será reemplazado por PaymentMethodDefinition) >>>
// enum PaymentMethod { ... }

model Ticket {
  id             String       @id @default(cuid())
  ticketNumber   String // Número de ticket operativo (puede ser diferente al fiscal)
  type           TicketType   @default(SALE) // <<< AÑADIDO: Tipo de ticket (Venta/Devolución)
  status         TicketStatus @default(OPEN)
  issueDate      DateTime     @default(now())
  currencyCode   String // <<< NUEVO: Moneda del ticket (Asegurarse que esté presente)
  totalAmount    Float // Importe total bruto (suma de items antes de descuentos globales)
  // <<< ELIMINADO discountAmount >>>
  // discountAmount Float        @default(0) // Descuento GLOBAL aplicado al ticket 
  taxAmount      Float // Importe total de impuestos (suma de IVA de items)
  finalAmount    Float // Importe final (total - descuento + impuestos)
  notes          String?
  // <<< NUEVOS CAMPOS: Serie y Vendedor >>>
  ticketSeries   String? // Serie operativa del ticket (ej: T2024-CLI1)
  sellerUserId   String? // ID del usuario VENDEDOR (para comisiones)

  // Relaciones Cliente/Empresa
  clientId  String? // Cliente (persona física) si aplica
  client    Client?  @relation(fields: [clientId], references: [id])
  companyId String? // Empresa cliente si aplica (factura a empresa)
  company   Company? @relation(fields: [companyId], references: [id])

  // Relaciones Auditoría/Contexto
  cashierUserId String // User que emitió el ticket
  cashierUser   User         @relation("CashierUserTickets", fields: [cashierUserId], references: [id])
  // <<< NUEVA RELACIÓN: Vendedor >>>
  sellerUser    User?        @relation("SellerUserTickets", fields: [sellerUserId], references: [id], onDelete: SetNull) // Vendedor
  clinicId      String // Clínica donde se emitió
  clinic        Clinic       @relation(fields: [clinicId], references: [id])
  systemId      String
  system        System       @relation(fields: [systemId], references: [id], onDelete: Cascade)
  appointmentId String?      @unique // Cita asociada (si la venta proviene de una cita)
  appointment   Appointment? @relation(fields: [appointmentId], references: [id], onDelete: SetNull, map: "appointment_ticket_relation")

  // <<< INICIO: Añadir Relaciones Ticket >>>
  // Relación con Ticket Original (para devoluciones)
  originalTicketId String?
  originalTicket   Ticket?  @relation("TicketReturns", fields: [originalTicketId], references: [id], onDelete: Restrict, onUpdate: Restrict) // <<< CAMBIADO a Restrict
  returnTickets    Ticket[] @relation("TicketReturns")

  // Relación Opcional con Factura (si este ticket se facturó)
  invoiceId String?  @unique // Un ticket solo puede generar una factura
   invoice   Invoice? @relation("TicketInvoiceRelation") 
  //invoice   Invoice? @relation(fields: [invoiceId], references: [id], onDelete: SetNull, onUpdate: Restrict) // <<< DESCOMENTADO Y CONFIRMADO
  // <<< FIN: Añadir Relaciones Ticket >>>

  // Relaciones Inversas
  items    TicketItem[] // Líneas del ticket
  payments Payment[] // Pagos asociados a este ticket (Vinculación principal a Payment se moverá a Invoice)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([ticketNumber, systemId]) // Número de ticket único por sistema
  @@index([type]) // <<< AÑADIDO ÍNDICE
  @@index([status])
  @@index([issueDate])
  @@index([clientId])
  @@index([companyId])
  @@index([cashierUserId])
  // <<< NUEVOS ÍNDICES >>>
  @@index([sellerUserId])
  @@index([ticketSeries])
  // <<< FIN NUEVOS ÍNDICES >>>
  @@index([clinicId])
  @@index([systemId])
  @@index([appointmentId])
  @@index([originalTicketId]) // <<< AÑADIDO ÍNDICE
  @@index([invoiceId]) // <<< AÑADIDO ÍNDICE
  @@map("tickets")
}

model TicketItem {
  id                  String             @id @default(cuid())
  ticketId            String
  ticket              Ticket             @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  itemType            String // "SERVICE", "PRODUCT", "BONO_PURCHASE", "PACKAGE_PURCHASE"
  serviceId           String?
  service             Service?           @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  productId           String?
  product             Product?           @relation(fields: [productId], references: [id], onDelete: SetNull)
  bonoDefinitionId    String? // ID si se COMPRA un bono
  bonoDefinition      BonoDefinition?    @relation("PurchasedBonos", fields: [bonoDefinitionId], references: [id], onDelete: SetNull)
  packageDefinitionId String? // ID si se COMPRA un paquete
  packageDefinition   PackageDefinition? @relation("PurchasedPackages", fields: [packageDefinitionId], references: [id], onDelete: SetNull)

  description String
  quantity    Float

  // Precios y Descuentos
  unitPrice               Float
  originalUnitPrice       Float?
  isPriceOverridden       Boolean    @default(false)
  manualDiscountAmount    Float      @default(0)
  // <<< NUEVO CAMPO: Notas del Descuento Manual >>>
  discountNotes           String? // Justificación del descuento manual por línea
  promotionDiscountAmount Float      @default(0)
  appliedPromotionId      String?
  appliedPromotion        Promotion? @relation(fields: [appliedPromotionId], references: [id], onDelete: SetNull)

  // Impuestos
  vatRateId         String?
  vatRate           VATType? @relation("AppliedVATType", fields: [vatRateId], references: [id], onDelete: SetNull)
  vatAmount         Float
  originalVatTypeId String?
  originalVatType   VATType? @relation("OriginalVATType", fields: [originalVatTypeId], references: [id], onDelete: SetNull)

  // Importe Final
  finalPrice Float

  // <<< INICIO: Consumo de Bonos/Paquetes >>>
  consumedBonoInstanceId    String? // ID de la instancia de BONO consumida por este item (precio cero)
  consumedBonoInstance      BonoInstance?    @relation("ConsumedBonoSessions", fields: [consumedBonoInstanceId], references: [id], onDelete: SetNull)
  consumedPackageInstanceId String? // ID de la instancia de PAQUETE consumida por este item (precio cero)
  consumedPackageInstance   PackageInstance? @relation("ConsumedPackageItems", fields: [consumedPackageInstanceId], references: [id], onDelete: SetNull)
  // <<< FIN: Consumo de Bonos/Paquetes >>>

  // Datos Adicionales
  professionalUserId String?
  // <<< NUEVO CAMPO: Indicador Generación Automática >>>
  isValidationGenerated Boolean @default(false) // true si fue creado por validación de servicio

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ticketId])
  @@index([serviceId])
  @@index([productId])
  @@index([bonoDefinitionId])
  @@index([packageDefinitionId])
  @@index([vatRateId])
  @@index([originalVatTypeId])
  @@index([consumedBonoInstanceId]) // <<< AÑADIDO ÍNDICE
  @@index([consumedPackageInstanceId])
  @@index([appliedPromotionId])
  // <<< NUEVO ÍNDICE >>>
  @@index([isValidationGenerated])
  @@map("ticket_items")
}

// <<< NUEVO ENUM: Tipo de Factura >>>
enum InvoiceType {
  SALE // Factura de Venta emitida por la clínica
  PURCHASE // Factura de Compra recibida por la clínica
  // Podríamos añadir SALE_RETURN, PURCHASE_RETURN más adelante
}

// <<< NUEVO ENUM: Estado de Factura (Ejemplo) >>>
enum InvoiceStatus {
  DRAFT // Borrador
  SENT // Enviada
  PENDING // Pendiente de pago
  PAID // Pagada
  PARTIALLY_PAID // Pago parcial
  OVERDUE // Vencida
  VOID // Anulada
  // Podrían añadirse más estados según necesidad
}

// <<< NUEVO MODELO: Factura >>>
model Invoice {
  id            String      @id @default(cuid())
  invoiceNumber String // Número legal (generado secuencialmente por serie/tipo)
  invoiceSeries String // Serie de facturación (ej: "FV2024", "FC2024")
  type          InvoiceType // SALE o PURCHASE
  issueDate     DateTime    @default(now()) // Fecha emisión factura (considerar quitar @default si debe ser explícita)
  dueDate       DateTime? // Fecha vencimiento (opcional)
  status        String? // Estado (ej: "PENDING", "PAID", "OVERDUE", "VOID") - Podría ser Enum InvoiceStatus más adelante

  // Datos del Receptor (Venta) o Emisor (Compra)
  clientId          String? // Si es factura de VENTA a Cliente B2C
  client            Client?  @relation(fields: [clientId], references: [id], onDelete: SetNull)
  companyId         String? // Si es factura de VENTA a Cliente B2B
  company           Company? @relation("SaleInvoices", fields: [companyId], references: [id], onDelete: SetNull) // Nombre relación para inversa
  supplierCompanyId String? // Si es factura de COMPRA a Proveedor
  supplierCompany   Company? @relation("PurchaseInvoices", fields: [supplierCompanyId], references: [id], onDelete: Restrict) // Nombre relación para inversa

  // Datos Fiscales (Snapshot en el momento de la factura)
  emitterFiscalName  String?
  emitterTaxId       String?
  emitterAddress     String?
  receiverFiscalName String?
  receiverTaxId      String?
  receiverAddress    String?

  // Importes Resumen
  currencyCode   String // Moneda de la factura (ej: "EUR")
  subtotalAmount Float
  discountAmount Float  @default(0)
  taxAmount      Float
  totalAmount    Float

  notes String?

  // Vinculación Opcional a Ticket (Relación definida en Ticket)
  ticketId String? @unique

  // Vinculación a Factura Original (para rectificativas/abonos)
  originalInvoiceId String?
  originalInvoice   Invoice?  @relation("InvoiceReturns", fields: [originalInvoiceId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  returnInvoices    Invoice[] @relation("InvoiceReturns")

  // Relaciones Sistema y Auditoría
  systemId  String
  system    System   @relation(fields: [systemId], references: [id], onDelete: Restrict) // Usamos Restrict por defecto
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones Inversas (Solo las directas del modelo)
  items    InvoiceItem[]
  // La relación inversa a Ticket se define EN Ticket
  // La relación inversa a Payment se define EN Payment
   //ticket         Ticket?     @relation(fields: [ticketId], references: [id], onDelete: SetNull, onUpdate: Restrict)
            // DENTRO DE Invoice:
  ticket   Ticket?       @relation("TicketInvoiceRelation", fields: [ticketId], references: [id], onDelete: SetNull, onUpdate: Restrict)
  payments Payment[]

  @@unique([invoiceSeries, invoiceNumber, systemId])
  @@index([type])
  @@index([status])
  @@index([issueDate])
  @@index([clientId])
  @@index([companyId])
  @@index([supplierCompanyId])
  @@index([ticketId])
  @@index([originalInvoiceId])
  @@index([systemId])
  @@map("invoices")
}

// <<< NUEVO MODELO: Línea de Factura >>>
model InvoiceItem {
  id        String  @id @default(cuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  // Descripción
  description    String
  quantity       Float
  unitPrice      Float
  discountAmount Float  @default(0)

  // Referencia opcional
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)
  serviceId String?
  service   Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)

  // Impuestos
  vatRateId     String?
  vatRate       VATType? @relation("AppliedInvoiceVATType", fields: [vatRateId], references: [id], onDelete: SetNull) // Nombre para relación inversa en VATType
  vatPercentage Float
  vatAmount     Float

  // Importe Final
  finalPrice Float

  createdAt DateTime @default(now())

  @@index([invoiceId])
  @@index([productId])
  @@index([serviceId])
  @@index([vatRateId])
  @@map("invoice_items")
}

// <<< FIN: Micro-Tarea 2 - Añadir Modelos Invoice e InvoiceItem >>>

// <<< NUEVO ENUM: Tipo de Pago Contable >>>
enum PaymentType {
  DEBIT // Entrada de dinero para la clínica (Cobro)
  CREDIT // Salida de dinero de la clínica (Pago, Reembolso)
}

model Payment {
  id                   String      @id @default(cuid())
  type                 PaymentType // DEBIT (entrada), CREDIT (salida)
  amount               Float
  paymentDate          DateTime // Fecha y hora del pago
  status               String? // Ejemplo: 'COMPLETED', 'PENDING', 'FAILED'
  transactionReference String? // Referencia de la transacción (ej: ID de Stripe, número de transferencia)
  notes                String?

  // Relaciones
  systemId                  String
  clinicId                  String?
  userId                    String // Usuario que registró el pago
  ticketId                  String? // Ticket asociado (opcional)
  invoiceId                 String? // Factura asociada (opcional)
  paymentMethodDefinitionId String? // Método de pago utilizado (definición)
  posTerminalId             String? // TPV utilizado (si aplica)
  bankAccountId             String? // Cuenta bancaria utilizada (si aplica, ej: para transferencia)
  cashSessionId             String? // Sesión de caja asociada (si aplica)
  bonoInstanceId            String? // Instancia de bono utilizada (si aplica)
  // --- Nuevos campos para pagos de terceros --- 
  payerClientId             String? // Si paga un cliente diferente al del ticket/factura
  payerCompanyId            String? // Si paga una empresa diferente
  // --- Fin nuevos campos --- 

  system                  System                   @relation(fields: [systemId], references: [id], onDelete: Cascade)
  clinic                  Clinic?                  @relation(fields: [clinicId], references: [id]) // Relación inversa faltaba en Clinic?
  user                    User                     @relation(fields: [userId], references: [id])
  ticket                  Ticket?                  @relation(fields: [ticketId], references: [id])
  invoice                 Invoice?                 @relation(fields: [invoiceId], references: [id])
  paymentMethodDefinition PaymentMethodDefinition? @relation(fields: [paymentMethodDefinitionId], references: [id])
  posTerminal             PosTerminal?             @relation(fields: [posTerminalId], references: [id])
  bankAccount             BankAccount?             @relation(fields: [bankAccountId], references: [id])
  cashSession             CashSession?             @relation(fields: [cashSessionId], references: [id])
  bonoInstance            BonoInstance?            @relation(fields: [bonoInstanceId], references: [id])
  // --- Nuevas relaciones para pagos de terceros --- 
  payerClient             Client?                  @relation("PayerClientPayments", fields: [payerClientId], references: [id]) // <<< AÑADIR NOMBRE RELACIÓN
  payerCompany            Company?                 @relation("PayerCompanyPayments", fields: [payerCompanyId], references: [id]) // <<< AÑADIR NOMBRE RELACIÓN
  // --- Fin nuevas relaciones --- 

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([systemId])
  @@index([clinicId])
  @@index([userId])
  @@index([ticketId])
  @@index([invoiceId])
  @@index([paymentMethodDefinitionId])
  @@index([posTerminalId])
  @@index([bankAccountId])
  @@index([cashSessionId])
  @@index([bonoInstanceId])
  @@index([payerClientId]) // <<< AÑADIR ÍNDICE
  @@index([payerCompanyId]) // <<< AÑADIR ÍNDICE
}

enum CashSessionStatus {
  OPEN
  CLOSED
  RECONCILED // Arqueada/Conciliada
}

model CashSession {
  id              String            @id @default(cuid())
  userId          String // Usuario que abre/cierra la caja
  user            User              @relation(fields: [userId], references: [id])
  clinicId        String // Clínica donde se realiza la sesión
  clinic          Clinic            @relation(fields: [clinicId], references: [id])
  openingTime     DateTime          @default(now())
  closingTime     DateTime?
  status          CashSessionStatus @default(OPEN)
  openingBalance  Float // Saldo inicial en efectivo
  closingBalance  Float? // Saldo final contado
  expectedBalance Float? // Saldo esperado según movimientos
  difference      Float? // Diferencia (contado - esperado)
  notes           String?
  systemId        String
  system          System            @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  // Relaciones (Corregidas)
  cashMovements Payment[] // Descomentado inverso Payment

  @@index([userId])
  @@index([clinicId])
  @@index([openingTime])
  @@index([status])
  @@index([systemId])
  @@map("cash_sessions")
}

// --- Modelos Bonos y Paquetes ---

// Definición de un tipo de Bono
model BonoDefinition {
  id          String  @id @default(cuid())
  name        String // Nombre del bono (ej: Bono 5 Masajes)
  description String? // Descripción corta

  // --- Relación Exclusiva ---
  serviceId String?
  service   Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  // --- Cantidad (Usos/Sesiones para Servicio, Unidades para Producto) ---
  quantity Int @map("quantity")

  // --- Validez ---
  validityDays Int?

  // --- Precios y Costes Base (Global) ---
  price     Float
  costPrice Float? // <<< MOVER a BonoDefinitionSetting (Si se considera configuración/regla)

  // --- IVA Base (Global) ---
  vatTypeId String?
  vatType   VATType? @relation(fields: [vatTypeId], references: [id], onDelete: SetNull)

  // --- Comisiones Base (Opcional) ---
  // commissionType  String? // <<< MOVER a BonoDefinitionSetting
  // commissionValue Float? // <<< MOVER a BonoDefinitionSetting

  // --- Opciones App/Facturación ---
  // appearsInApp     Boolean @default(true) // <<< MOVER a BonoDefinitionSetting
  // autoAddToInvoice Boolean @default(false) // <<< MOVER a BonoDefinitionSetting

  // --- Otros ---
  // isActive      Boolean @default(true) // <<< MOVER a BonoDefinitionSetting
  // pointsAwarded Int     @default(0) // <<< MOVER a BonoDefinitionSetting

  // --- Relaciones Sistema y Auditoría ---
  systemId  String
  system    System   @relation(fields: [systemId], references: [id], onDelete: Cascade)

  // <<< NUEVA RELACIÓN 1-a-1 con BonoDefinitionSetting >>>
  settings BonoDefinitionSetting?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // --- Relaciones Inversas ---
  instances    BonoInstance[]
  tariffPrices TariffBonoPrice[]
  ticketItems  TicketItem[]      @relation("PurchasedBonos")

  // Relacion Inversa Promocion
  targetedPromotions Promotion[] @relation("TargetBonoDefinition")

  @@unique([name, systemId])
  @@index([systemId])
  @@index([serviceId])
  @@index([productId])
  @@index([vatTypeId])
  @@map("bono_definitions")
}

// --- NUEVO MODELO: Configuración de BonoDefinition ---
model BonoDefinitionSetting {
  id                 String  @id @default(cuid())
  bonoDefinitionId   String  @unique
  bonoDefinition     BonoDefinition @relation(fields: [bonoDefinitionId], references: [id], onDelete: Cascade)

  // Campos movidos
  validityDays       Int?
  costPrice          Float? // Si se considera configuración
  commissionType     String?
  commissionValue    Float?
  appearsInApp       Boolean @default(true)
  autoAddToInvoice   Boolean @default(false)
  isActive           Boolean @default(true)
  pointsAwarded      Int     @default(0)

  // Otras posibles configuraciones futuras:
  // - Reglas de canje (días específicos, horas específicas)
  // - Límite de uso por día/semana
  // - Si es transferible
  // ...

  @@map("bono_definition_settings")
}
// --- FIN NUEVO MODELO BONO ---

// Instancia específica de un bono comprada por un cliente
model BonoInstance {
  id                   String         @id @default(cuid())
  bonoDefinitionId     String
  bonoDefinition       BonoDefinition @relation(fields: [bonoDefinitionId], references: [id])
  clientId             String
  client               Client         @relation(fields: [clientId], references: [id])
  purchaseDate         DateTime       @default(now())
  expiryDate           DateTime?
  remainingQuantity    Int
  purchaseTicketItemId String?        @unique
  systemId             String
  system               System         @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt

  // <<< INICIO: Relación Inversa Consumo >>>
  consumedItems TicketItem[] @relation("ConsumedBonoSessions") // Items de ticket donde se consumió una sesión DE ESTA INSTANCIA
  // <<< FIN: Relación Inversa Consumo >>>

  // <<< AÑADIR RELACIÓN INVERSA FALTANTE >>>
  payments Payment[] // Para Payment.bonoInstance

  @@index([clientId])
  @@index([bonoDefinitionId])
  @@index([systemId])
  @@index([purchaseTicketItemId])
  @@map("bono_instances")
}

// Definición de un Paquete (agrupación de servicios/productos)
model PackageDefinition {
  id            String  @id @default(cuid())
  name          String
  description   String?
  price         Float // Precio total del paquete
  // isActive      Boolean @default(true) // <<< MOVER a PackageDefinitionSetting
  // pointsAwarded Int     @default(0) // <<< MOVER a PackageDefinitionSetting
  systemId      String
  system        System  @relation(fields: [systemId], references: [id], onDelete: Cascade)

  // Relaciones
  items        PackageItem[]
  tariffPrices TariffPackagePrice[]

  // <<< AÑADIR RELACIONES INVERSAS >>>
  ticketItems      TicketItem[]      @relation("PurchasedPackages")
  packageInstances PackageInstance[]

  // <<< NUEVA RELACIÓN 1-a-1 con PackageDefinitionSetting >>>
  settings PackageDefinitionSetting?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // <<< AÑADIR RELACION INVERSA PROMOCION >>>
  targetedPromotions Promotion[] @relation("TargetPackageDefinition")

  @@unique([name, systemId])
  @@index([systemId])
  @@map("package_definitions")
}

// --- NUEVO MODELO: Configuración de PackageDefinition ---
model PackageDefinitionSetting {
  id                    String  @id @default(cuid())
  packageDefinitionId   String  @unique
  packageDefinition     PackageDefinition @relation(fields: [packageDefinitionId], references: [id], onDelete: Cascade)

  // Campos movidos
  isActive              Boolean @default(true)
  pointsAwarded         Int     @default(0)

  // Otras posibles configuraciones futuras:
  // - Visibilidad en App
  // - Reglas de caducidad global
  // - Si requiere pago por adelantado
  // ...

  @@map("package_definition_settings")
}
// --- FIN NUEVO MODELO PAQUETE ---

// Item dentro de un Paquete (puede ser Servicio o Producto)
model PackageItem {
  id                  String            @id @default(cuid())
  packageDefinitionId String
  packageDefinition   PackageDefinition @relation(fields: [packageDefinitionId], references: [id], onDelete: Cascade)
  itemType            String // "SERVICE" o "PRODUCT"

  // --- Relación Exclusiva Service/Product ---
  // TODO API Validation: Ensure serviceId OR productId is set, not both.
  serviceId String?
  service   Service? @relation(fields: [serviceId], references: [id], onDelete: Restrict) // <-- Cambiado a Restrict
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: Restrict) // <-- Cambiado a Restrict
  // --- Fin Relación Exclusiva ---

  quantity Float // Cantidad del item incluida en el paquete

  // <<< AÑADIR PRECIO POR LÍNEA >>>
  price Float? // Precio específico de este item DENTRO del paquete (opcional)
  // <<< FIN AÑADIR >>>

  createdAt DateTime @default(now())

  @@index([packageDefinitionId])
  @@index([serviceId])
  @@index([productId])
  @@map("package_items")
}

// <<< NUEVO MODELO: Instancia de Paquete Comprado >>>
model PackageInstance {
  id                   String            @id @default(cuid())
  packageDefinitionId  String
  packageDefinition    PackageDefinition @relation(fields: [packageDefinitionId], references: [id]) // Relación definida aquí
  clientId             String
  client               Client            @relation(fields: [clientId], references: [id])
  purchaseDate         DateTime          @default(now())
  purchaseTicketItemId String?           @unique // Item del ticket donde se compró este paquete (opcional)
  // purchaseTicketItem TicketItem? @relation(fields: [purchaseTicketItemId], references: [id]) // Relación opcional

  // Estructura JSON para rastrear items restantes
  // Ejemplo: { "service:<serviceId>": remainingQuantity, "product:<productId>": remainingQuantity }
  remainingItems Json

  systemId  String
  system    System   @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones Inversas
  consumedItems TicketItem[] @relation("ConsumedPackageItems") // <<< AÑADIDO: Items de ticket donde se consumió un item DE ESTA INSTANCIA

  @@index([clientId])
  @@index([packageDefinitionId])
  @@index([systemId])
  @@index([purchaseTicketItemId])
  @@map("package_instances")
}

// --- Modelo Promociones ---

enum PromotionAccumulationMode {
  EXCLUSIVE // No se acumula con ninguna otra.
  ALL // Se acumula con cualquier otra promoción acumulable.
  SPECIFIC // Se acumula solo con las promociones definidas explícitamente.
}

enum PromotionType {
  PERCENTAGE_DISCOUNT // Descuento porcentual sobre item/ticket
  FIXED_AMOUNT_DISCOUNT // Descuento de cantidad fija sobre item/ticket
  BUY_X_GET_Y_SERVICE // Compra X (del item objetivo), llévate Y servicio(s) gratis/descuento
  BUY_X_GET_Y_PRODUCT // Compra X (del item objetivo), llévate Y producto(s) gratis/descuento
  POINTS_MULTIPLIER // Multiplicador de puntos de fidelidad
  FREE_SHIPPING // Envío gratuito (si aplica a futuro)
}

enum PromotionTargetScope {
  SPECIFIC_SERVICE // Aplica a un Servicio específico globalmente
  SPECIFIC_PRODUCT // Aplica a un Producto específico globalmente
  SPECIFIC_BONO // Aplica a un BonoDefinition específico globalmente
  SPECIFIC_PACKAGE // Aplica a un PackageDefinition específico globalmente
  CATEGORY // Aplica a una Categoría específica globalmente
  TARIFF // Aplica a una Tarifa específica (y a todo lo incluido)
  // TICKET_TOTAL // Aplica al total del ticket
}

model Promotion {
  id          String  @id @default(cuid())
  name        String
  description String?
  code        String? @unique
  isActive    Boolean @default(true)
  systemId    String
  system      System  @relation(fields: [systemId], references: [id], onDelete: Cascade)

  // Tipo y Valor
  type            PromotionType
  value           Float? // Ej: 10.0 para 10%, 5.0 para 5€, 2.0 para 2x puntos
  bogoBuyQuantity Int?

  // Objetivo de la Promoción
  targetScope               PromotionTargetScope
  targetServiceId           String?
  targetService             Service?             @relation("TargetService", fields: [targetServiceId], references: [id], onDelete: Cascade)
  targetProductId           String?
  targetProduct             Product?             @relation("TargetProduct", fields: [targetProductId], references: [id], onDelete: Cascade)
  targetBonoDefinitionId    String?
  targetBonoDefinition      BonoDefinition?      @relation("TargetBonoDefinition", fields: [targetBonoDefinitionId], references: [id], onDelete: Cascade)
  targetPackageDefinitionId String?
  targetPackageDefinition   PackageDefinition?   @relation("TargetPackageDefinition", fields: [targetPackageDefinitionId], references: [id], onDelete: Cascade)
  targetCategoryId          String?
  targetCategory            Category?            @relation("TargetCategory", fields: [targetCategoryId], references: [id], onDelete: Cascade)
  targetTariffId            String?
  targetTariff              Tariff?              @relation("TargetTariff", fields: [targetTariffId], references: [id], onDelete: Cascade)

  // Regalo/Beneficio BOGO (BUY_X_GET_Y)
  bogoGetServiceId String?
  bogoGetService   Service? @relation("BogoService", fields: [bogoGetServiceId], references: [id], onDelete: SetNull)
  bogoGetProductId String?
  bogoGetProduct   Product? @relation("BogoProduct", fields: [bogoGetProductId], references: [id], onDelete: SetNull)
  bogoGetQuantity  Int?
  bogoGetValue     Float? // Descuento a aplicar al item regalado (si no es gratis)

  // Condiciones y Límites
  minPurchaseAmount Float?
  maxDiscountAmount Float?
  startDate         DateTime?
  endDate           DateTime?
  maxTotalUses      Int?
  maxUsesPerClient  Int?

  // Alcance Geográfico/Clínica
  applicableClinics PromotionClinicScope[]

  // Acumulación
  accumulationMode       PromotionAccumulationMode @default(EXCLUSIVE)
  definedCompatibilities PromotionCompatibility[]  @relation("DefinedCompatibility")
  compatibleWith         PromotionCompatibility[]  @relation("CompatibleWith")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relación Inversa con TicketItem
  appliedToTicketItems TicketItem[]

  @@unique([name, systemId])
  @@index([systemId])
  @@index([code])
  @@index([startDate, endDate])
  @@index([type])
  @@index([targetScope])
  @@index([targetServiceId])
  @@index([targetProductId])
  @@index([targetBonoDefinitionId])
  @@index([targetPackageDefinitionId])
  @@index([targetCategoryId])
  @@index([targetTariffId])
  @@index([bogoGetServiceId])
  @@index([bogoGetProductId])
  @@map("promotions")
}

// --- MODELO PARA REGISTRAR USOS (Opcional pero recomendado) ---
// ... (Modelo PromotionUsage omitido por ahora) ...

// --- Modelo Fidelidad (Puntos) ---

enum LoyaltyMovementType {
  AWARDED_PURCHASE // Puntos ganados por compra
  REDEEMED_PAYMENT // Puntos usados para pagar
  MANUAL_ADJUSTMENT // Ajuste manual (positivo o negativo)
  EXPIRATION // Puntos caducados
  PROMOTION_AWARD // Puntos extra por promoción
  INITIAL_BALANCE // Saldo inicial
}

model LoyaltyLedger {
  id           String              @id @default(cuid())
  clientId     String
  client       Client              @relation(fields: [clientId], references: [id])
  movementType LoyaltyMovementType
  points       Int // Puntos ganados (+) o gastados (-)
  movementDate DateTime            @default(now())
  notes        String?
  expiryDate   DateTime? // Fecha de caducidad para estos puntos (si aplica)
  userId       String? // Usuario que realizó el ajuste manual
  user         User?               @relation(fields: [userId], references: [id], onDelete: SetNull)
  systemId     String
  system       System              @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt    DateTime            @default(now())

  @@index([clientId])
  @@index([movementDate])
  @@index([systemId])
  @@index([userId])
  @@map("loyalty_ledgers")
}

// --- Modelos Habilidades Profesionales ---

model Skill {
  id          String   @id @default(cuid())
  name        String // Nombre de la habilidad (ej: "Experto Láser Diodo", "Masaje Terapéutico")
  description String?
  systemId    String // ¿Habilidades globales o por sistema? Por ahora por sistema.
  system      System   @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relaciones
  users UserSkill[] // Usuarios que tienen esta habilidad

  // <<< NUEVA RELACIÓN INVERSA >>>
  requiredByServices ServiceSkillRequirement[]

  @@unique([name, systemId])
  @@index([systemId])
  @@map("skills")
}

// Tabla de unión para la relación Muchos-a-Muchos entre User y Skill
model UserSkill {
  userId     String
  skillId    String
  assignedAt DateTime @default(now())

  // Relaciones
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  skill Skill @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@id([userId, skillId]) // Clave primaria compuesta
  @@index([userId])
  @@index([skillId])
  @@map("user_skills")
}

// --- Modelos Archivos Adjuntos (Polimórfico) ---

enum EntityType {
  SYSTEM
  USER
  CLIENT
  COMPANY
  CONTACT_PERSON
  LEAD
  CLINIC
  EQUIPMENT
  DEVICE
  SERVICE
  PRODUCT
  APPOINTMENT
  TICKET
  INVOICE // <<< AÑADIDO
  PAYMENT
  EMPLOYMENT_CONTRACT
  BANK // <<< AÑADIDO
  BANK_ACCOUNT // <<< AÑADIDO
  PROMOTION // <<< AÑADIDO
  BONO_DEFINITION // <<< AÑADIDO
  PACKAGE_DEFINITION // <<< AÑADIDO
}

model EntityImage {
  id               String     @id @default(cuid())
  entityId         String // ID de la entidad relacionada (Client.id, User.id, etc.)
  entityType       EntityType // Tipo de la entidad relacionada
  imageUrl         String // URL de la imagen (ej: Supabase Storage)
  altText          String? // Texto alternativo para accesibilidad
  caption          String? // Leyenda o descripción corta
  order            Int? // Orden opcional si hay múltiples imágenes para una entidad
  isProfilePic     Boolean    @default(false) // Indicador especial para fotos de perfil (User/Client)
  uploadedByUserId String?
  uploadedByUser   User?      @relation("UploadedImages", fields: [uploadedByUserId], references: [id], onDelete: SetNull)
  systemId         String
  system           System     @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  @@index([entityId, entityType]) // Índice clave para buscar imágenes de una entidad
  @@index([uploadedByUserId]) // Índice añadido
  @@index([systemId])
  @@map("entity_images")
}

model EntityDocument {
  id               String     @id @default(cuid())
  entityId         String // ID de la entidad relacionada
  entityType       EntityType // Tipo de la entidad relacionada
  documentUrl      String // URL del documento (ej: Supabase Storage)
  fileName         String // Nombre original del archivo
  fileType         String? // Tipo MIME (ej: "application/pdf", "image/jpeg")
  fileSize         Int? // Tamaño en bytes
  description      String?
  uploadedByUserId String?
  uploadedByUser   User?      @relation("UploadedDocuments", fields: [uploadedByUserId], references: [id], onDelete: SetNull)
  systemId         String
  system           System     @relation(fields: [systemId], references: [id], onDelete: Cascade)
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  @@index([entityId, entityType]) // Índice clave para buscar documentos de una entidad
  @@index([uploadedByUserId]) // Índice añadido
  @@index([systemId])
  @@map("entity_documents")
}

// --- NUEVO MODELO PARA ASIGNACIÓN USUARIO-CLINICA ---
model UserClinicAssignment {
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  clinicId   String
  clinic     Clinic   @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  roleId     String // ID del Rol que el usuario tiene en ESTA clínica
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade) // Relación con Role
  assignedAt DateTime @default(now())

  // --- HORARIO/EXCEPCIONES PERSONALIZADAS VINCULADAS A ESTA ASIGNACIÓN ---
  customSchedule   UserClinicSchedule? // Un usuario puede tener UN horario personalizado por asignación
  customExceptions UserClinicScheduleException[] // Un usuario puede tener MUCHAS excepciones por asignación

  @@id([userId, clinicId]) // Clave primaria: Usuario solo tiene UN rol por clínica
  @@index([clinicId])
  @@index([roleId]) // << AÑADIR ÍNDICE para roleId
  @@map("user_clinic_assignments")
}

// --- NUEVO MODELO: Horario Personalizado de Usuario por Clínica ---
model UserClinicSchedule {
  id         String               @id @default(cuid())
  // Referencia directa a User y Clinic
  userId     String
  clinicId   String
  user       User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  clinic     Clinic               @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  // Relación One-to-One explícita con UserClinicAssignment
  assignment UserClinicAssignment @relation(fields: [userId, clinicId], references: [userId, clinicId], onDelete: Cascade)

  scheduleJson Json // Almacena el objeto WeekSchedule personalizado
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([userId, clinicId]) // Asegurar un único horario por usuario/clínica
  @@index([userId])
  @@index([clinicId])
  @@map("user_clinic_schedules")
}

// --- NUEVO MODELO: Excepción de Horario Personalizada de Usuario por Clínica ---
model UserClinicScheduleException {
  id         String               @id @default(cuid())
  // Referencia directa a User y Clinic
  userId     String
  clinicId   String
  user       User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  clinic     Clinic               @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  // Relación Many-to-One explícita con UserClinicAssignment
  assignment UserClinicAssignment @relation(fields: [userId, clinicId], references: [userId, clinicId], onDelete: Cascade)

  name         String? // Nombre opcional para la excepción (ej: "Vacaciones Verano 2024")
  startDate    DateTime @db.Date // Fecha de inicio de la excepción
  endDate      DateTime @db.Date // Fecha de fin de la excepción
  scheduleJson Json // Almacena el objeto WeekSchedule que APLICA DURANTE la excepción
  // Este horario sobrescribe el base/personalizado en esas fechas.
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId, clinicId, startDate]) // Índice para buscar excepciones por usuario/clínica/fecha
  @@index([userId, clinicId]) // << AÑADIR ESTE ÍNDICE PARA LA RELACIÓN
  @@map("user_clinic_schedule_exceptions")
}

// --- NUEVO MODELO PARA CATEGORÍAS/FAMILIAS ---
model Category {
  id          String     @id @default(cuid())
  name        String // Nombre de la categoría/familia
  description String?
  // type        CategoryType? // Podría ser un Enum si necesitamos diferenciar (SERVICE, PRODUCT)
  systemId    String // A qué sistema pertenece esta categoría
  system      System     @relation(fields: [systemId], references: [id], onDelete: Cascade)
  // Jerarquía
  parentId    String? // ID de la categoría padre
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  children    Category[] @relation("CategoryHierarchy") // Subcategorías
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Relaciones Inversas
  services           Service[]
  products           Product[]
  targetedPromotions Promotion[] @relation("TargetCategory")

  @@unique([name, systemId]) // Nombre único por sistema
  @@index([systemId])
  @@index([parentId]) // Índice para buscar hijos
  @@map("categories")
}

// --- FIN NUEVO MODELO ---

// --- NUEVO MODELO PARA CABINAS DE CLÍNICA ---
model Cabin {
  id        String   @id @default(cuid())
  name      String // Nombre de la cabina (ej: "Cabina Láser 1", "Sala Estética")
  code      String? // Código corto identificativo (ej: "CAB1", "EST")
  color     String? // Color asociado para visualización (ej: "#4f46e5")
  order     Int? // Orden de visualización
  isActive  Boolean  @default(true)
  clinicId  String // Clínica a la que pertenece
  clinic    Clinic   @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  systemId  String // Sistema al que pertenece (derivado de Clinic)
  system    System   @relation(fields: [systemId], references: [id], onDelete: Cascade) // Para queries directas
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, clinicId]) // Nombre único por clínica
  @@unique([code, clinicId]) // Código único por clínica (si se usa)
  @@index([clinicId])
  @@index([systemId])
  @@map("cabins")
}

// --- FIN NUEVO MODELO CABINA ---

// --- ELIMINAR Modelo ClinicTemplateAssignment ---
// <<< Modelo eliminado completo >>>

// --- Modelo para Bloqueos Específicos de Horario de Cabina ---

model CabinScheduleOverride {
  id                String    @id @default(cuid())
  clinicId          String
  clinic            Clinic    @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  cabinIds          String[]
  startDate         DateTime  @map("start_date")
  endDate           DateTime? @map("end_date")
  startTime         String    @map("start_time")
  endTime           String    @map("end_time")
  description       String?
  isRecurring       Boolean   @default(false) @map("is_recurring")
  daysOfWeek        Int[]     @map("days_of_week")
  recurrenceEndDate DateTime? @map("recurrence_end_date")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  @@index([clinicId, startDate, endDate])
  @@map("cabin_schedule_overrides")
}

// --- FIN MODELO BLOQUEOS ---

// --- NUEVO MODELO: Precio específico de Servicio por Tarifa ---
model TariffServicePrice {
  tariffId  String
  tariff    Tariff   @relation(fields: [tariffId], references: [id], onDelete: Cascade)
  serviceId String
  service   Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  price     Float // Precio específico del servicio en esta tarifa
  vatTypeId String? // IVA específico para este servicio en esta tarifa (opcional, puede heredar)
  vatType   VATType? @relation(fields: [vatTypeId], references: [id], onDelete: SetNull) // Permitir SetNull
  isActive  Boolean  @default(true) // Permite desactivar el servicio en esta tarifa sin borrar la entrada

  @@id([tariffId, serviceId]) // Clave primaria compuesta
  @@index([serviceId])
  @@index([vatTypeId])
  @@map("tariff_service_prices")
}

// --- FIN NUEVO MODELO ---

// --- NUEVO MODELO: Precio específico de Producto por Tarifa ---
model TariffProductPrice {
  tariffId  String
  tariff    Tariff   @relation(fields: [tariffId], references: [id], onDelete: Cascade)
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  price     Float // Precio específico del producto en esta tarifa
  vatTypeId String? // IVA específico para este producto en esta tarifa (opcional)
  vatType   VATType? @relation(fields: [vatTypeId], references: [id], onDelete: SetNull) // Permitir SetNull
  isActive  Boolean  @default(true) // Permite desactivar el producto en esta tarifa sin borrar la entrada

  @@id([tariffId, productId]) // Clave primaria compuesta
  @@index([productId])
  @@index([vatTypeId])
  @@map("tariff_product_prices")
}

// --- FIN NUEVO MODELO ---

// --- NUEVO MODELO: Precio específico de Bono por Tarifa ---
model TariffBonoPrice {
  tariffId         String
  tariff           Tariff         @relation(fields: [tariffId], references: [id], onDelete: Cascade)
  bonoDefinitionId String
  bonoDefinition   BonoDefinition @relation(fields: [bonoDefinitionId], references: [id], onDelete: Cascade)
  price            Float // Precio específico del Bono en esta tarifa
  vatTypeId        String? // IVA específico para este Bono en esta tarifa (opcional, hereda de Tarifa si es null)
  vatType          VATType?       @relation(fields: [vatTypeId], references: [id], onDelete: SetNull)
  isActive         Boolean        @default(true)

  @@id([tariffId, bonoDefinitionId]) // Clave primaria compuesta
  @@index([bonoDefinitionId])
  @@index([vatTypeId])
  @@map("tariff_bono_prices")
}

// --- FIN NUEVO MODELO ---

// --- NUEVO MODELO: Precio específico de Paquete por Tarifa ---
model TariffPackagePrice {
  tariffId            String
  tariff              Tariff            @relation(fields: [tariffId], references: [id], onDelete: Cascade)
  packageDefinitionId String
  packageDefinition   PackageDefinition @relation(fields: [packageDefinitionId], references: [id], onDelete: Cascade)
  price               Float // Precio específico del Paquete en esta tarifa
  vatTypeId           String? // IVA específico para este Paquete en esta tarifa (opcional, hereda de Tarifa si es null)
  vatType             VATType?          @relation(fields: [vatTypeId], references: [id], onDelete: SetNull)
  isActive            Boolean           @default(true)

  @@id([tariffId, packageDefinitionId]) // Clave primaria compuesta
  @@index([packageDefinitionId])
  @@index([vatTypeId])
  @@map("tariff_package_prices")
}

// --- FIN NUEVO MODELO ---

// --- NUEVO MODELO: Tabla Intermedia para Alcance de Promoción por Clínica ---
model PromotionClinicScope {
  promotionId String
  clinicId    String

  promotion Promotion @relation(fields: [promotionId], references: [id], onDelete: Cascade)
  clinic    Clinic    @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  @@id([promotionId, clinicId])
  @@index([promotionId])
  @@index([clinicId])
  @@map("promotion_clinic_scopes")
}

// --- FIN NUEVO MODELO ---

// <<< NUEVO MODELO: Compatibilidad entre Promociones >>>
model PromotionCompatibility {
  promotionId           String
  compatiblePromotionId String
  systemId              String // <<< VUELVE A SER OBLIGATORIO
  system                System @relation(fields: [systemId], references: [id], onDelete: Cascade) // <<< VUELVE A SER OBLIGATORIO

  promotion           Promotion @relation("DefinedCompatibility", fields: [promotionId], references: [id], onDelete: Cascade)
  compatiblePromotion Promotion @relation("CompatibleWith", fields: [compatiblePromotionId], references: [id], onDelete: Cascade)

  @@id([promotionId, compatiblePromotionId])
  @@index([compatiblePromotionId])
  @@index([systemId]) // Mantenemos el índice
  @@map("promotion_compatibilities")
}

// <<< FIN NUEVO MODELO >>>

// --- NUEVO MODELO ---
model ClinicPaymentSetting {
  id                            String   @id @default(cuid())
  isActiveInClinic              Boolean  @default(true)
  receivingBankAccountId        String? // Cuenta bancaria específica para recibir ingresos en esta clínica (opcional)
  posTerminalId                 String? // TPV asociado a esta configuración (si es de tipo Tarjeta)
  isDefaultPosTerminal          Boolean? @default(false) // Es el TPV por defecto para pagos con tarjeta en la clínica
  isDefaultReceivingBankAccount Boolean? @default(false) // Es la cuenta por defecto para ingresos en la clínica

  // --- RELACIONES --- 
  systemId                  String
  clinicId                  String
  paymentMethodDefinitionId String

  system                  System                  @relation(fields: [systemId], references: [id], onDelete: Cascade)
  clinic                  Clinic                  @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  paymentMethodDefinition PaymentMethodDefinition @relation(fields: [paymentMethodDefinitionId], references: [id], onDelete: Cascade)
  // <<< AJUSTAR RELACIÓN >>>
  receivingBankAccount    BankAccount?            @relation("BankAccountSettings", fields: [receivingBankAccountId], references: [id])
  posTerminal             PosTerminal?            @relation("PosTerminalSettings", fields: [posTerminalId], references: [id])

  // @@unique([clinicId, paymentMethodDefinitionId]) // <<< ELIMINAR ANTIGUA CLAVE ÚNICA >>>
  @@unique([systemId, clinicId, paymentMethodDefinitionId]) // <<< AÑADIR NUEVA CLAVE ÚNICA CON systemId >>>
  @@index([receivingBankAccountId])
  @@index([posTerminalId]) // <<< AÑADIR ÍNDICE >>>
  @@map("clinic_payment_settings")
}
